{
    "include/bzp_type.h": "# 1 \".tmp/include/bzp_type.h\"\n# 17 \".tmp/include/bzp_type.h\"\n#ifndef BZP_TYPE_H\n#define BZP_TYPE_H\n\n#define BZP_OK 0\n\nenum BZP_ERROR_BASE_NO {\n  BZP_ERROR_MEMORY_OPER_FAILURE = 1,\n  BZP_ERROR_PARAM,\n  BZP_ERROR_IO,\n  BZP_ERROR_DATA,\n  BZP_ERROR_DATA_MAGIC,\n};\n\nenum BZP_ERROR_STREAM_NO { BZP_ERROR_STREAM_COMPRESS_FAILUIRE = 10 };\n\ntypedef enum { BZP_ERROR_BASE_NO, BZP_ERROR_STREAM_NO } BZP_ERROR_NO;\n\n#endif\n",
    "src/public/bzp_compress_stream.h": "# 1 \".tmp/src/public/bzp_compress_stream.h\"\n# 17 \".tmp/src/public/bzp_compress_stream.h\"\n#ifndef BZP_COM_STREAM_H\n#define BZP_COM_STREAM_H\n\n#include \"bzp_bwt_encode.h\"\n#include \"bzp_huffman_encode.h\"\n#include \"bzp_mtf_encode.h\"\n#include \"bzp_stream_utils.h\"\n#include \"bzp_type.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define BZP_INPUT_COMPRESS 0\n#define BZP_OUTPUT_COMPRESS 1\n#define BZP_RETUEN_COMPRESS 2\n\ntypedef struct {\n  BzpStream *input;\n  BzpStream *output;\n  int32_t state;\n  int32_t lasChar;\n  int32_t num;\n  int32_t pad;\n} BzpFile;\n\ntypedef struct {\n  uint8_t *out;\n  int32_t num;\n  uint32_t buf;\n  int32_t nBuf;\n  int32_t blockSize;\n} BzpOutComdata;\n\ntypedef struct {\n  BzpBwtInfo *bwt;\n  BzpHuffmanGroups *huffman;\n  BzpMtfInfo *mtf;\n  BzpFile *compressFile;\n  BzpOutComdata *outData;\n} BzpAlgorithmInfo;\n\nBzpAlgorithmInfo *BzpAlgorithmInfoInit(int32_t blockSize);\nint32_t BzpOpenFile(BzpAlgorithmInfo *bzpInfo, char *inName, char *outName);\nvoid BzpAlgorithmInfoFinish(BzpAlgorithmInfo *bzpInfo);\n\nBzpOutComdata *BzpOutComDataInit(int32_t blockSize);\n\nvoid BzpOutComDataFinish(BzpOutComdata *data);\n\nvoid BzpWriteToArray(int32_t val, int32_t n, BzpOutComdata *data);\n\nvoid BzpWriteInt32(int32_t val, BzpOutComdata *data);\n\nint32_t BzpCompressOneBlock(BzpAlgorithmInfo *bzpInfo, BzpOutComdata *outData);\n\nint32_t BzpBuffToStream(BzpFile *bzpf, BzpOutComdata *outData);\nvoid BzpAddCharToBlock(uint8_t lasch, int32_t num, BzpBwtInfo *bwt);\n\nvoid BzpBuffToBlockRLC(BzpFile *bzpf, BzpBwtInfo *bwt, bool IsLastdata);\n\nvoid BzpResetCompress(BzpBwtInfo *bwt, BzpOutComdata *outData);\n\nint32_t BzpProcessData(BzpAlgorithmInfo *bzpInfo, bool IsLastdata);\n\nint32_t BzpCompressStream(char *inName, char *outName, int32_t blockSize);\n\nvoid BzpCompressEnd(BzpAlgorithmInfo *bzpInfo);\n\nBzpFile *BzpFileInit();\n\nvoid BzpFileFinish(BzpFile *bzpF);\n\nvoid BzpWriteFileHead(BzpOutComdata *outData, int32_t blockId);\n\nvoid BzpCalculateCRC(BzpBwtInfo *bwt);\n\nvoid BzpWriteBlockHead(BzpOutComdata *outData, BzpBwtInfo *bwt);\n\nvoid BzpWriteFileEnd(BzpOutComdata *outData, int32_t combinedCRC);\n\nvoid BzpFlushbuf(BzpOutComdata *outData);\n\nvoid BzpWriteValidASCII(BzpOutComdata *outData, BzpBwtInfo *bwt);\n\nvoid BzpWriteSelect(BzpOutComdata *outData, BzpHuffmanGroups *huffman);\n\nvoid BzpWriteLen(BzpOutComdata *outData, BzpHuffmanGroups *huffman);\n\nvoid BzpWriteInputEncode(BzpOutComdata *outData, BzpMtfInfo *mtf,\n                         BzpHuffmanGroups *huffman);\n\nbool BzpFileEOF(FILE *f);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
    "src/public/bzp_compress_stream.c": "# 1 \".tmp/src/public/bzp_compress_stream.c\"\n# 17 \".tmp/src/public/bzp_compress_stream.c\"\n#include \"bzp_compress_stream.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nBzpAlgorithmInfo *BzpAlgorithmInfoInit(int32_t blockSize) {\n  BzpAlgorithmInfo *bzpInfo =\n      (BzpAlgorithmInfo *)malloc(sizeof(BzpAlgorithmInfo));\n  if (bzpInfo == NULL) {\n    return NULL;\n  }\n  bzpInfo->bwt = BzpBlockSortInit(blockSize);\n  bzpInfo->mtf = BzpMtfInit(blockSize);\n  bzpInfo->huffman = BzpHuffmanGroupsInit(blockSize);\n  bzpInfo->outData = BzpOutComDataInit(blockSize);\n  bzpInfo->compressFile = BzpFileInit();\n\n  if (bzpInfo->bwt == NULL || bzpInfo->outData == NULL ||\n      bzpInfo->compressFile == NULL || bzpInfo->mtf == NULL ||\n      bzpInfo->huffman == NULL) {\n    BzpAlgorithmInfoFinish(bzpInfo);\n    return NULL;\n  }\n  return bzpInfo;\n}\nint32_t BzpOpenFile(BzpAlgorithmInfo *bzpInfo, char *inName, char *outName) {\n  if (bzpInfo == NULL) {\n    return BZP_ERROR_PARAM;\n  }\n  bzpInfo->compressFile->input->filePtr = fopen(inName, \"rb\");\n  bzpInfo->compressFile->output->filePtr = fopen(outName, \"wb\");\n  if ((bzpInfo->compressFile->input->filePtr == NULL ||\n       bzpInfo->compressFile->output->filePtr == NULL)) {\n    BzpAlgorithmInfoFinish(bzpInfo);\n    remove(outName);\n    return BZP_ERROR_IO;\n  }\n  return BZP_OK;\n}\nvoid BzpAlgorithmInfoFinish(BzpAlgorithmInfo *bzpInfo) {\n  if (bzpInfo != NULL) {\n    BzpBwtFinish(bzpInfo->bwt);\n    BzpMtfFinish(bzpInfo->mtf);\n    BzpBzpHuffmanGroupsFinish(bzpInfo->huffman);\n    BzpFileFinish(bzpInfo->compressFile);\n    BzpOutComDataFinish(bzpInfo->outData);\n    free(bzpInfo);\n  }\n}\nBzpFile *BzpFileInit() {\n  BzpFile *compressFile = (BzpFile *)malloc(sizeof(BzpFile));\n  BzpStream *inStream = BzpStreamInit();\n  BzpStream *outStream = BzpStreamInit();\n  if (compressFile == NULL || inStream == NULL || outStream == NULL) {\n    BzpStreamFinish(inStream);\n    BzpStreamFinish(outStream);\n    BzpFileFinish(compressFile);\n    return NULL;\n  }\n  compressFile->input = inStream;\n  compressFile->output = outStream;\n  compressFile->input->pos = 0;\n  compressFile->output->pos = 0;\n  compressFile->num = 0;\n  compressFile->lasChar = BZP_ASCII_SIZE;\n  compressFile->state = BZP_INPUT_COMPRESS;\n  return compressFile;\n}\nvoid BzpFileFinish(BzpFile *bzpF) {\n  if (bzpF != NULL) {\n    BzpStreamFinish(bzpF->input);\n    BzpStreamFinish(bzpF->output);\n    free(bzpF);\n    bzpF = NULL;\n  }\n}\nBzpOutComdata *BzpOutComDataInit(int32_t blockSize) {\n  BzpOutComdata *outData = (BzpOutComdata *)malloc(sizeof(BzpOutComdata));\n  if (outData == NULL) {\n    return NULL;\n  }\n  outData->out = NULL;\n\n  outData->out =\n      (uint8_t *)malloc(blockSize * BZP_BASE_BLOCK_SIZE * sizeof(uint32_t));\n  if (outData->out == NULL) {\n    free(outData);\n    return NULL;\n  }\n  outData->nBuf = 0;\n  outData->buf = 0;\n  outData->num = 0;\n  outData->blockSize = blockSize;\n  return outData;\n}\nvoid BzpOutComDataFinish(BzpOutComdata *data) {\n  if (data != NULL) {\n    if (data->out != NULL) {\n      free(data->out);\n      data->out = NULL;\n    }\n    free(data);\n    data = NULL;\n  }\n}\n\nvoid BzpWriteToArray(int32_t val, int32_t n, BzpOutComdata *data) {\n\n  while (data->nBuf >= BZP_BITS8) {\n    data->out[data->num++] = (uint8_t)(data->buf >> BZP_BITS24);\n    data->nBuf -= BZP_BITS8;\n    data->buf <<= BZP_BITS8;\n  }\n  data->buf |= (val << (BZP_BITS32 - n - data->nBuf));\n  data->nBuf += n;\n}\n\nvoid BzpWriteInt32(int32_t val, BzpOutComdata *data) {\n\n  BzpWriteToArray((val >> BZP_BITS24) & 0xffL, BZP_BITS8, data);\n  BzpWriteToArray((val >> BZP_BITS16) & 0xffL, BZP_BITS8, data);\n  BzpWriteToArray((val >> BZP_BITS8) & 0xffL, BZP_BITS8, data);\n  BzpWriteToArray(val & 0xffL, BZP_BITS8, data);\n}\n\nbool BzpFileEOF(FILE *f) {\n  int32_t c = fgetc(f);\n  if (c == BZP_EOF)\n    return true;\n  (void)ungetc(c, f);\n  return false;\n}\nvoid BzpWriteFileHead(BzpOutComdata *outData, int32_t blockId) {\n  if (blockId == 0) {\n    BzpWriteToArray(BZP_HDR_B, BZP_BITS8, outData);\n    BzpWriteToArray(BZP_HDR_Z, BZP_BITS8, outData);\n    BzpWriteToArray(BZP_HDR_H, BZP_BITS8, outData);\n    BzpWriteToArray((BZP_HDR_0 + outData->blockSize), BZP_BITS8, outData);\n  }\n}\nvoid BzpCalculateCRC(BzpBwtInfo *bwt) {\n  bwt->blockCRC = ~(bwt->blockCRC);\n  bwt->combinedCRC =\n      (bwt->combinedCRC << 1) | (bwt->combinedCRC >> BZP_CRC_MOVE_RIGHT_VAL);\n  bwt->combinedCRC ^= bwt->blockCRC;\n}\n\nvoid BzpWriteBlockHead(BzpOutComdata *outData, BzpBwtInfo *bwt) {\n  BzpWriteToArray(BZP_BLOCK_HEAD_0, BZP_BITS8, outData);\n  BzpWriteToArray(BZP_BLOCK_HEAD_1, BZP_BITS8, outData);\n  BzpWriteToArray(BZP_BLOCK_HEAD_2, BZP_BITS8, outData);\n  BzpWriteToArray(BZP_BLOCK_HEAD_3, BZP_BITS8, outData);\n  BzpWriteToArray(BZP_BLOCK_HEAD_4, BZP_BITS8, outData);\n  BzpWriteToArray(BZP_BLOCK_HEAD_5, BZP_BITS8, outData);\n  BzpWriteInt32(bwt->blockCRC, outData);\n  BzpWriteToArray(0, BZP_BIT, outData);\n  BzpWriteToArray(bwt->oriPtr, BZP_BITS24, outData);\n}\nvoid BzpWriteValidASCII(BzpOutComdata *outData, BzpBwtInfo *bwt) {\n  int32_t validGid[BZP_ASCII_SIZE], cnt = 0;\n  bool use16[BZP_ASCII_SIZE];\n  (void)memset_s(use16, sizeof(use16), 0, sizeof(use16));\n\n  for (int32_t i = 0; i < BZP_ASCII_SIZE; i++) {\n    int32_t gid = i / BZP_CHARS_PER_GROUP_ASCII;\n    use16[gid] |= bwt->inUse[i];\n  }\n  for (int32_t i = 0; i < BZP_GROUPS_ASCII; i++) {\n    BzpWriteToArray((int32_t)(use16[i]), BZP_BIT, outData);\n    if (use16[i]) {\n      validGid[cnt++] = i;\n    }\n  }\n  for (int32_t i = 0; i < cnt; i++) {\n    for (int32_t j = 0; j < BZP_CHARS_PER_GROUP_ASCII; j++) {\n      int32_t valid = validGid[i] * BZP_CHARS_PER_GROUP_ASCII + j;\n      BzpWriteToArray((int32_t)(bwt->inUse[valid]), BZP_BIT, outData);\n    }\n  }\n}\n\nvoid BzpWriteSelect(BzpOutComdata *outData, BzpHuffmanGroups *huffman) {\n\n  BzpWriteToArray(huffman->nSelect, BZP_BITS15, outData);\n\n  for (int32_t i = 0; i < huffman->nSelect; i++) {\n    for (int32_t j = 0; j < huffman->selectMTF[i]; j++) {\n      BzpWriteToArray(1, BZP_BIT, outData);\n    }\n    BzpWriteToArray(0, BZP_BIT, outData);\n  }\n}\nvoid BzpWriteLen(BzpOutComdata *outData, BzpHuffmanGroups *huffman) {\n  for (int32_t i = 0; i < huffman->nGroups; i++) {\n    int32_t val = huffman->huffmanGroups[i].len[0];\n    BzpWriteToArray(val, BZP_BITS5, outData);\n\n    for (int32_t j = 0; j < huffman->alphaSize; j++) {\n      int32_t tar = huffman->huffmanGroups[i].len[j];\n      int32_t deta = 0, saveVal = 0;\n      if (val < tar) {\n        saveVal = BZP_HUFFMAN_LEN_INCREASE;\n        deta = 1;\n      } else if (val > tar) {\n        saveVal = BZP_HUFFMAN_LEN_REDUCED;\n        deta = -1;\n      }\n      while (val != tar) {\n        BzpWriteToArray(saveVal, BZP_BITS2, outData);\n        val += deta;\n      }\n      BzpWriteToArray(0, BZP_BIT, outData);\n    }\n  }\n}\nvoid BzpWriteInputEncode(BzpOutComdata *outData, BzpMtfInfo *mtf,\n                         BzpHuffmanGroups *huffman) {\n  for (int32_t i = 0; i < mtf->nMtf; i++) {\n    int32_t val = mtf->mtfV[i];\n    int32_t gid = huffman->select[i / BZP_ELEMS_NUM_IN_ONE_GROUP];\n    int32_t code = huffman->huffmanGroups[gid].table[val];\n    int32_t len = huffman->huffmanGroups[gid].len[val];\n    BzpWriteToArray(code, len, outData);\n  }\n}\nvoid BzpWriteFileEnd(BzpOutComdata *outData, int32_t combinedCRC) {\n  BzpWriteToArray(BZP_FILE_END_0, BZP_BITS8, outData);\n  BzpWriteToArray(BZP_FILE_END_1, BZP_BITS8, outData);\n  BzpWriteToArray(BZP_FILE_END_2, BZP_BITS8, outData);\n  BzpWriteToArray(BZP_FILE_END_3, BZP_BITS8, outData);\n  BzpWriteToArray(BZP_FILE_END_4, BZP_BITS8, outData);\n  BzpWriteToArray(BZP_FILE_END_5, BZP_BITS8, outData);\n  BzpWriteInt32(combinedCRC, outData);\n}\n\nvoid BzpFlushbuf(BzpOutComdata *outData) {\n  while (outData->nBuf > 0) {\n    outData->out[outData->num++] = (uint8_t)(outData->buf >> BZP_BITS24);\n    outData->nBuf -= BZP_BITS8;\n    outData->buf <<= BZP_BITS8;\n  }\n}\n\nint32_t BzpCompressOneBlock(BzpAlgorithmInfo *bzpInfo, BzpOutComdata *outData) {\n  BzpBwtInfo *bwt = bzpInfo->bwt;\n  BzpMtfInfo *mtf = bzpInfo->mtf;\n  BzpHuffmanGroups *huffman = bzpInfo->huffman;\n  int ret = BZP_OK;\n  if (bwt->nBlock == 0) {\n    return BZP_OK;\n  }\n\n  BzpWriteFileHead(outData, bwt->blockId);\n  if (bwt->nBlock > 0) {\n\n    BzpCalculateCRC(bwt);\n\n    BzpBlockSortMain(bwt);\n\n    BzpMtfReSet(mtf);\n\n    mtf->block = bwt->block;\n    mtf->map = bwt->sortBlock;\n    mtf->inUse = bwt->inUse;\n    mtf->nBlock = bwt->nBlock;\n\n    BzpMtfMain(mtf);\n\n    ret = BzpHuffmanGroupsReset(huffman, mtf->nUse + BZP_EXTRA_CHARS_NUM);\n    if (ret != BZP_OK) {\n      return ret;\n    }\n\n    huffman->block = mtf->mtfV;\n    huffman->mtfFreq = mtf->mtfFreq;\n    huffman->nBlock = mtf->nMtf;\n\n    BzpHuffmanMain(huffman);\n\n    BzpWriteBlockHead(outData, bwt);\n\n    BzpWriteValidASCII(outData, bwt);\n\n    BzpWriteToArray(huffman->nGroups, BZP_BITS3, outData);\n\n    BzpWriteSelect(outData, huffman);\n\n    BzpWriteLen(outData, huffman);\n\n    BzpWriteInputEncode(outData, mtf, huffman);\n  }\n  return BZP_OK;\n}\n\nint32_t BzpBuffToStream(BzpFile *bzpf, BzpOutComdata *outData) {\n  bzpf->output->pos = 0;\n\n  int32_t pos = 0;\n\n  while (pos < outData->num) {\n    bzpf->output->nBuf = 0;\n\n    while (pos < outData->num && bzpf->output->nBuf < BZP_BUF_SIZE) {\n      bzpf->output->buf[bzpf->output->nBuf++] = outData->out[pos];\n      pos++;\n    }\n    int32_t n2 = fwrite((void *)(bzpf->output->buf), sizeof(uint8_t),\n                        bzpf->output->nBuf, bzpf->output->filePtr);\n    if (n2 != bzpf->output->nBuf) {\n      return BZP_ERROR_IO;\n    }\n  }\n  return BZP_OK;\n}\nvoid BzpAddCharToBlock(uint8_t lasch, int32_t num, BzpBwtInfo *bwt) {\n  if (num < BZP_RLC_NUM_LOWER_LIMIT || num > BZP_RLC_NUM_UPPER_LIMIT) {\n    return;\n  }\n  for (int32_t i = 0; i < num; i++) {\n    BZP_UPDATE_CRC(bwt->blockCRC, lasch);\n  }\n\n  int32_t val = BZP_MIN_FUN(num, (int32_t)BZP_RLC_NUM_4);\n  switch (val) {\n  case BZP_RLC_NUM_4:\n    bwt->block[bwt->nBlock++] = lasch;\n\n  case BZP_RLC_NUM_3:\n    bwt->block[bwt->nBlock++] = lasch;\n\n  case BZP_RLC_NUM_2:\n    bwt->block[bwt->nBlock++] = lasch;\n\n  case BZP_RLC_NUM_1:\n    bwt->block[bwt->nBlock++] = lasch;\n\n  default:\n    break;\n  }\n  if (num >= BZP_RLC_NUM_4) {\n    bwt->block[bwt->nBlock++] = ((char)(num - BZP_RLC_NUM_4));\n    bwt->inUse[num - BZP_RLC_NUM_4] = true;\n  }\n\n  bwt->inUse[lasch] = true;\n}\n\nvoid BzpBuffToBlockRLC(BzpFile *bzpf, BzpBwtInfo *bwt, bool IsLastdata) {\n\n  while (!BZP_BLOCK_FULL && !BZP_BUFF_READ_EMPTY) {\n    int32_t pos = bzpf->input->pos;\n    uint8_t ch = (uint8_t)bzpf->input->buf[pos];\n    uint8_t lasch = (uint8_t)bzpf->lasChar;\n    if (ch != lasch || bzpf->num == BZP_RLC_NUM_UPPER_LIMIT) {\n      BzpAddCharToBlock(lasch, bzpf->num, bwt);\n      bzpf->lasChar = ch;\n      bzpf->num = 1;\n    } else {\n      bzpf->num++;\n    }\n\n    bzpf->input->pos++;\n  }\n\n  if (IsLastdata && BZP_BUFF_READ_EMPTY) {\n\n    BzpAddCharToBlock(bzpf->lasChar, bzpf->num, bwt);\n    bzpf->lasChar = BZP_ASCII_SIZE;\n    bzpf->num = 0;\n  }\n}\n\nvoid BzpResetCompress(BzpBwtInfo *bwt, BzpOutComdata *outData) {\n\n  outData->num = 0;\n\n  bwt->nBlock = 0;\n  bwt->blockCRC = BZP_INIT_BLOCK_CRC;\n  (void)memset_s(bwt->inUse, sizeof(bwt->inUse), 0, sizeof(bwt->inUse));\n  int32_t n = outData->blockSize * BZP_BASE_BLOCK_SIZE * sizeof(int32_t);\n  (void)memset_s(bwt->isStartPos, n, 0, n);\n  bwt->blockId++;\n}\n\nint32_t BzpProcessData(BzpAlgorithmInfo *bzpInfo, bool IsLastdata) {\n  BzpFile *bzpf = bzpInfo->compressFile;\n  BzpOutComdata *outData = bzpInfo->outData;\n  BzpBwtInfo *bwt = bzpInfo->bwt;\n\n  bzpf->state = BZP_INPUT_COMPRESS;\n  int32_t ret = BZP_OK;\n  while (bzpf->state != BZP_RETUEN_COMPRESS) {\n    if (bzpf->state == BZP_OUTPUT_COMPRESS) {\n\n      ret = BzpBuffToStream(bzpf, outData);\n\n      BzpResetCompress(bwt, outData);\n      bzpf->state = BZP_INPUT_COMPRESS;\n      if (IsLastdata && BZP_BUFF_READ_EMPTY) {\n        bzpf->state = BZP_RETUEN_COMPRESS;\n      }\n    }\n    if (bzpf->state == BZP_INPUT_COMPRESS) {\n\n      BzpBuffToBlockRLC(bzpf, bwt, IsLastdata);\n\n      if (IsLastdata && BZP_BUFF_READ_EMPTY) {\n        ret = BzpCompressOneBlock(bzpInfo, outData);\n\n        BzpWriteFileEnd(outData, bwt->combinedCRC);\n        BzpFlushbuf(outData);\n\n        bzpf->state = BZP_OUTPUT_COMPRESS;\n      } else if (BZP_BLOCK_FULL) {\n        ret = BzpCompressOneBlock(bzpInfo, outData);\n        bzpf->state = BZP_OUTPUT_COMPRESS;\n      } else {\n        bzpf->state = BZP_RETUEN_COMPRESS;\n      }\n    }\n    if (ret != BZP_OK) {\n      return ret;\n    }\n  }\n  return ret;\n}\nvoid BzpCompressEnd(BzpAlgorithmInfo *bzpInfo) {\n\n  if (bzpInfo->compressFile->input->filePtr != NULL) {\n    fclose(bzpInfo->compressFile->input->filePtr);\n  }\n  if (bzpInfo->compressFile->output->filePtr != NULL) {\n    fclose(bzpInfo->compressFile->output->filePtr);\n  }\n  BzpAlgorithmInfoFinish(bzpInfo);\n}\n\nint32_t BzpCompressStream(char *inName, char *outName, int32_t blockSize) {\n\n  int32_t ret = BZP_OK;\n  bool IsLastdata = false;\n\n  if (inName == NULL || outName == NULL || BZP_INVALID_BLOCK_SIZE(blockSize)) {\n    return BZP_ERROR_PARAM;\n  }\n\n  BzpAlgorithmInfo *bzpInfo = BzpAlgorithmInfoInit(blockSize);\n  if (bzpInfo == NULL) {\n    return BZP_ERROR_MEMORY_OPER_FAILURE;\n  }\n  ret = BzpOpenFile(bzpInfo, inName, outName);\n  if (ret != BZP_OK) {\n    return ret;\n  }\n  BzpStream *inStream = bzpInfo->compressFile->input;\n\n  while (!IsLastdata) {\n    inStream->nBuf = fread(inStream->buf, sizeof(char), sizeof(inStream->buf),\n                           inStream->filePtr);\n    inStream->pos = 0;\n    IsLastdata = BzpFileEOF(inStream->filePtr);\n    ret = BzpProcessData(bzpInfo, IsLastdata);\n    if (ret != BZP_OK) {\n      break;\n    }\n  }\n  BzpCompressEnd(bzpInfo);\n  if (ret != BZP_OK) {\n    remove(outName);\n  }\n  return ret;\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
    "src/public/bzp_utils.h": "# 1 \".tmp/src/public/bzp_utils.h\"\n# 17 \".tmp/src/public/bzp_utils.h\"\n#ifndef BZP_UTILS_H\n#define BZP_UTILS_H\n\n#include \"bzp_type.h\"\n#include \"securec.h\"\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define BZP_BASE_BLOCK_SIZE 100000\n\n#define BZP_BLOCK_SIZE_LEVEL_UPPER_LIMIT 9\n#define BZP_BLOCK_SIZE_LEVEL_LOWER_LIMIT 1\n\n#define BZP_INVALID_BLOCK_SIZE(blockSize)                                      \\\n  ((blockSize) < BZP_BLOCK_SIZE_LEVEL_LOWER_LIMIT ||                           \\\n   (blockSize) > BZP_BLOCK_SIZE_LEVEL_UPPER_LIMIT)\n\n#define BZP_INVALID_ALPHA_SIZE(alphaSize)                                      \\\n  ((alphaSize) > BZP_MAX_ALPHA_SIZE || (alphaSize) < 1)\n\n#define BZP_BLOCK_RESERVED_SPACE_SIZE 19\n\n#define BZP_THRESHOLD_SHELL_SORT 10\n\n#define BZP_MAX_STACK_SIZE 100\n\n#define BZP_ASCII_SIZE 256\n\n#define BZP_SHELL_SORT_INCREMENT_NUMS 2\n\n#define BZP_SHELL_SORT_INCREMENT0 1\n#define BZP_SHELL_SORT_INCREMENT1 4\n\n#define BZP_MTF_ENCODE0 0\n#define BZP_MTF_ENCODE1 1\n#define BZP_MTF_ENCODE_BASE 2\n\n#define BZP_INIT_BLOCK_CRC 0xffffffffL\n\n#define BZP_MAX_ALPHA_SIZE 258\n\n#define BZP_MAX_GROUPS_NUM 6\n\n#define BZP_MAX_ITER_NUM 4\n\n#define BZP_MAX_TREE_HEIGHT_ENCODE 17\n\n#define BZP_NGROUPS_BLOCK_NUM_LIMIT0 200\n#define BZP_NGROUPS_BLOCK_NUM_LIMIT1 600\n#define BZP_NGROUPS_BLOCK_NUM_LIMIT2 1200\n#define BZP_NGROUPS_BLOCK_NUM_LIMIT3 2400\n#define BZP_NGROUPS_NUM_0 2\n#define BZP_NGROUPS_NUM_1 3\n#define BZP_NGROUPS_NUM_2 4\n#define BZP_NGROUPS_NUM_3 5\n#define BZP_NGROUPS_NUM_4 6\n\n#define BZP_ELEMS_NUM_IN_ONE_GROUP 50\n\n#define BZP_HUFFMAN_HEIGHT_WEIGHT_BITS 8\n\n#define BZP_HUFFMAN_LEN_MAX_COST 15\n\n#define BZP_HUFFMAN_LEN_UPPER_LIMIT 20\n\n#define BZP_HUFFMAN_MAX_SIZE_SELECT                                            \\\n  (BZP_BLOCK_SIZE_LEVEL_UPPER_LIMIT * BZP_BASE_BLOCK_SIZE /                    \\\n   BZP_ELEMS_NUM_IN_ONE_GROUP)\n\n#define BZP_MAX_FUN(a, b) (((a) > (b)) ? (a) : (b))\n#define BZP_MIN_FUN(a, b) (((a) < (b)) ? (a) : (b))\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
    "src/public/bzp_decompress_stream.h": "# 1 \".tmp/src/public/bzp_decompress_stream.h\"\n# 17 \".tmp/src/public/bzp_decompress_stream.h\"\n#ifndef BZP_DECOM_STREAM_H\n#define BZP_DECOM_STREAM_H\n\n#include \"bzp_bwt_decode.h\"\n#include \"bzp_huffman_decode.h\"\n#include \"bzp_stream_utils.h\"\n#include \"bzp_type.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n  BzpStream *input;\n  BzpStream *output;\n  int32_t lasChar;\n  int32_t num;\n  uint32_t buf;\n  int32_t nBuf;\n  int32_t blockSize;\n  uint32_t blockCRC;\n  int32_t list[BZP_ASCII_SIZE];\n} InDeComdata;\n\nInDeComdata *BzpInDeComdataInit();\n\nvoid BzpInDeComdataFinish(InDeComdata *inData);\n\nuint32_t BzpReadBits(int32_t nBit, InDeComdata *inData);\n\nint32_t BzpWriteChar(uint8_t ch, InDeComdata *inData);\n\nint32_t BzpHuffmanDecodeStep(BzpHuffmanDecode *huffman, InDeComdata *inData);\n\nint32_t BzpDeCompressOneBlock(InDeComdata *inData, BzpHuffmanDecode *huffman,\n                              BzpBwtDecodeInfo *debwt);\n\nint32_t BZPReadFileEnd(InDeComdata *inData, uint32_t caltotalCRC);\n\nint32_t BZPDeCompressData(InDeComdata *inData);\nvoid BzpDeComStreamFinish(InDeComdata *inData, BzpStream *inStream,\n                          BzpStream *outStream);\n\nint32_t BzpDeCompressStream(char *inName, char *outName);\n\nint32_t BzpCheckFileHead(InDeComdata *inData);\n\nuint32_t BzpReadUInt32(InDeComdata *inData);\n\nuint32_t BzpReadUInt24(InDeComdata *inData);\n\nint32_t BzpDeHuffmanSelect(InDeComdata *inData, BzpHuffmanDecode *huffman);\n\nint32_t BzpDeHuffmanLen(InDeComdata *inData, BzpHuffmanDecode *huffman);\n\nint32_t BzpMTFDeCode(InDeComdata *inData, BzpHuffmanDecode *huffman,\n                     BzpBwtDecodeInfo *debwt);\n\nint32_t BzpDeCodeToStream(InDeComdata *inData, BzpBwtDecodeInfo *debwt);\n\nint32_t BzpGetDictionaryList(InDeComdata *inData);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
    "src/public/bzp_stream_utils.c": "# 1 \".tmp/src/public/bzp_stream_utils.c\"\n# 17 \".tmp/src/public/bzp_stream_utils.c\"\n#include \"bzp_stream_utils.h\"\n\nint32_t g_bzpCRC32Table[256] = {\n\n    0x00000000L, 0x04c11db7L, 0x09823b6eL, 0x0d4326d9L, 0x130476dcL,\n    0x17c56b6bL, 0x1a864db2L, 0x1e475005L, 0x2608edb8L, 0x22c9f00fL,\n    0x2f8ad6d6L, 0x2b4bcb61L, 0x350c9b64L, 0x31cd86d3L, 0x3c8ea00aL,\n    0x384fbdbdL, 0x4c11db70L, 0x48d0c6c7L, 0x4593e01eL, 0x4152fda9L,\n    0x5f15adacL, 0x5bd4b01bL, 0x569796c2L, 0x52568b75L, 0x6a1936c8L,\n    0x6ed82b7fL, 0x639b0da6L, 0x675a1011L, 0x791d4014L, 0x7ddc5da3L,\n    0x709f7b7aL, 0x745e66cdL, 0x9823b6e0L, 0x9ce2ab57L, 0x91a18d8eL,\n    0x95609039L, 0x8b27c03cL, 0x8fe6dd8bL, 0x82a5fb52L, 0x8664e6e5L,\n    0xbe2b5b58L, 0xbaea46efL, 0xb7a96036L, 0xb3687d81L, 0xad2f2d84L,\n    0xa9ee3033L, 0xa4ad16eaL, 0xa06c0b5dL, 0xd4326d90L, 0xd0f37027L,\n    0xddb056feL, 0xd9714b49L, 0xc7361b4cL, 0xc3f706fbL, 0xceb42022L,\n    0xca753d95L, 0xf23a8028L, 0xf6fb9d9fL, 0xfbb8bb46L, 0xff79a6f1L,\n    0xe13ef6f4L, 0xe5ffeb43L, 0xe8bccd9aL, 0xec7dd02dL, 0x34867077L,\n    0x30476dc0L, 0x3d044b19L, 0x39c556aeL, 0x278206abL, 0x23431b1cL,\n    0x2e003dc5L, 0x2ac12072L, 0x128e9dcfL, 0x164f8078L, 0x1b0ca6a1L,\n    0x1fcdbb16L, 0x018aeb13L, 0x054bf6a4L, 0x0808d07dL, 0x0cc9cdcaL,\n    0x7897ab07L, 0x7c56b6b0L, 0x71159069L, 0x75d48ddeL, 0x6b93dddbL,\n    0x6f52c06cL, 0x6211e6b5L, 0x66d0fb02L, 0x5e9f46bfL, 0x5a5e5b08L,\n    0x571d7dd1L, 0x53dc6066L, 0x4d9b3063L, 0x495a2dd4L, 0x44190b0dL,\n    0x40d816baL, 0xaca5c697L, 0xa864db20L, 0xa527fdf9L, 0xa1e6e04eL,\n    0xbfa1b04bL, 0xbb60adfcL, 0xb6238b25L, 0xb2e29692L, 0x8aad2b2fL,\n    0x8e6c3698L, 0x832f1041L, 0x87ee0df6L, 0x99a95df3L, 0x9d684044L,\n    0x902b669dL, 0x94ea7b2aL, 0xe0b41de7L, 0xe4750050L, 0xe9362689L,\n    0xedf73b3eL, 0xf3b06b3bL, 0xf771768cL, 0xfa325055L, 0xfef34de2L,\n    0xc6bcf05fL, 0xc27dede8L, 0xcf3ecb31L, 0xcbffd686L, 0xd5b88683L,\n    0xd1799b34L, 0xdc3abdedL, 0xd8fba05aL, 0x690ce0eeL, 0x6dcdfd59L,\n    0x608edb80L, 0x644fc637L, 0x7a089632L, 0x7ec98b85L, 0x738aad5cL,\n    0x774bb0ebL, 0x4f040d56L, 0x4bc510e1L, 0x46863638L, 0x42472b8fL,\n    0x5c007b8aL, 0x58c1663dL, 0x558240e4L, 0x51435d53L, 0x251d3b9eL,\n    0x21dc2629L, 0x2c9f00f0L, 0x285e1d47L, 0x36194d42L, 0x32d850f5L,\n    0x3f9b762cL, 0x3b5a6b9bL, 0x0315d626L, 0x07d4cb91L, 0x0a97ed48L,\n    0x0e56f0ffL, 0x1011a0faL, 0x14d0bd4dL, 0x19939b94L, 0x1d528623L,\n    0xf12f560eL, 0xf5ee4bb9L, 0xf8ad6d60L, 0xfc6c70d7L, 0xe22b20d2L,\n    0xe6ea3d65L, 0xeba91bbcL, 0xef68060bL, 0xd727bbb6L, 0xd3e6a601L,\n    0xdea580d8L, 0xda649d6fL, 0xc423cd6aL, 0xc0e2d0ddL, 0xcda1f604L,\n    0xc960ebb3L, 0xbd3e8d7eL, 0xb9ff90c9L, 0xb4bcb610L, 0xb07daba7L,\n    0xae3afba2L, 0xaafbe615L, 0xa7b8c0ccL, 0xa379dd7bL, 0x9b3660c6L,\n    0x9ff77d71L, 0x92b45ba8L, 0x9675461fL, 0x8832161aL, 0x8cf30badL,\n    0x81b02d74L, 0x857130c3L, 0x5d8a9099L, 0x594b8d2eL, 0x5408abf7L,\n    0x50c9b640L, 0x4e8ee645L, 0x4a4ffbf2L, 0x470cdd2bL, 0x43cdc09cL,\n    0x7b827d21L, 0x7f436096L, 0x7200464fL, 0x76c15bf8L, 0x68860bfdL,\n    0x6c47164aL, 0x61043093L, 0x65c52d24L, 0x119b4be9L, 0x155a565eL,\n    0x18197087L, 0x1cd86d30L, 0x029f3d35L, 0x065e2082L, 0x0b1d065bL,\n    0x0fdc1becL, 0x3793a651L, 0x3352bbe6L, 0x3e119d3fL, 0x3ad08088L,\n    0x2497d08dL, 0x2056cd3aL, 0x2d15ebe3L, 0x29d4f654L, 0xc5a92679L,\n    0xc1683bceL, 0xcc2b1d17L, 0xc8ea00a0L, 0xd6ad50a5L, 0xd26c4d12L,\n    0xdf2f6bcbL, 0xdbee767cL, 0xe3a1cbc1L, 0xe760d676L, 0xea23f0afL,\n    0xeee2ed18L, 0xf0a5bd1dL, 0xf464a0aaL, 0xf9278673L, 0xfde69bc4L,\n    0x89b8fd09L, 0x8d79e0beL, 0x803ac667L, 0x84fbdbd0L, 0x9abc8bd5L,\n    0x9e7d9662L, 0x933eb0bbL, 0x97ffad0cL, 0xafb010b1L, 0xab710d06L,\n    0xa6322bdfL, 0xa2f33668L, 0xbcb4666dL, 0xb8757bdaL, 0xb5365d03L,\n    0xb1f740b4L};\n\nBzpStream *BzpStreamInit() {\n  BzpStream *stream = (BzpStream *)malloc(sizeof(BzpStream));\n  if (stream == NULL) {\n    return NULL;\n  }\n  stream->filePtr = NULL;\n  stream->pos = 0;\n  stream->nBuf = 0;\n  return stream;\n}\n\nvoid BzpStreamFinish(BzpStream *stream) {\n  if (stream != NULL) {\n    free(stream);\n    stream = NULL;\n  }\n}\n",
    "src/public/bzp_stream_utils.h": "# 1 \".tmp/src/public/bzp_stream_utils.h\"\n# 17 \".tmp/src/public/bzp_stream_utils.h\"\n#ifndef BZP_STREAM_UTILS_H\n#define BZP_STREAM_UTILS_H\n\n#include \"securec.h\"\n#include <stdint.h>\n#include <stdio.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define BZP_HDR_B 0x42\n#define BZP_HDR_Z 0x5a\n#define BZP_HDR_H 0x68\n#define BZP_HDR_0 0x30\n\n#define BZP_BLOCK_HEAD_0 0x31\n#define BZP_BLOCK_HEAD_1 0x41\n#define BZP_BLOCK_HEAD_2 0x59\n#define BZP_BLOCK_HEAD_3 0x26\n#define BZP_BLOCK_HEAD_4 0x53\n#define BZP_BLOCK_HEAD_5 0x59\n\n#define BZP_FILE_END_0 0x17\n#define BZP_FILE_END_1 0x72\n#define BZP_FILE_END_2 0x45\n#define BZP_FILE_END_3 0x38\n#define BZP_FILE_END_4 0x50\n#define BZP_FILE_END_5 0x90\n\n#define BZP_BUF_SIZE 5000\n\n#define BZP_EOF (-1)\n\n#define BZP_BIT 1\n#define BZP_BITS2 2\n#define BZP_BITS3 3\n#define BZP_BITS5 5\n#define BZP_BITS8 8\n#define BZP_BITS15 15\n#define BZP_BITS16 16\n#define BZP_BITS24 24\n#define BZP_BITS32 32\n\n#define BZP_RLC_NUM_1 1\n#define BZP_RLC_NUM_2 2\n#define BZP_RLC_NUM_3 3\n#define BZP_RLC_NUM_4 4\n\n#define BZP_RLC_NUM_LOWER_LIMIT 1\n#define BZP_RLC_NUM_UPPER_LIMIT 255\n\n#define BZP_GROUPS_ASCII 16\n\n#define BZP_CHARS_PER_GROUP_ASCII 16\n\n#define BZP_CRC_MOVE_RIGHT_VAL 31\n\n#define BZP_HUFFMAN_LEN_INCREASE 2\n#define BZP_HUFFMAN_LEN_REDUCED 3\n\n#define BZP_EXTRA_CHARS_NUM 2\n\n#define BZP_BLOCK_FULL (bwt->nBlock >= bwt->nBlockMax)\n\n#define BZP_BUFF_READ_EMPTY (bzpf->input->pos >= bzpf->input->nBuf)\n\ntypedef struct {\n  FILE *filePtr;\n  int32_t nBuf;\n  int32_t pos;\n  uint8_t buf[BZP_BUF_SIZE];\n} BzpStream;\n\nextern int32_t g_bzpCRC32Table[256];\n\nBzpStream *BzpStreamInit();\n\nvoid BzpStreamFinish(BzpStream *stream);\n\n#define BZP_UPDATE_CRC(crcVar, cha)                                            \\\n  {                                                                            \\\n    (crcVar) = ((crcVar) << 8) ^                                               \\\n               g_bzpCRC32Table[((crcVar) >> 24) ^ ((uint8_t)(cha))];           \\\n  }\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
    "src/public/bzp_decompress_stream.c": "# 1 \".tmp/src/public/bzp_decompress_stream.c\"\n# 17 \".tmp/src/public/bzp_decompress_stream.c\"\n#include \"bzp_decompress_stream.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nInDeComdata *BzpInDeComdataInit() {\n  InDeComdata *inData = (InDeComdata *)malloc(sizeof(InDeComdata));\n  if (inData == NULL) {\n    return NULL;\n  }\n  inData->input = NULL;\n  inData->output = NULL;\n  inData->num = 0;\n  inData->lasChar = BZP_ASCII_SIZE;\n  inData->nBuf = 0;\n  inData->buf = 0;\n  inData->num = 0;\n\n  inData->blockCRC = BZP_INIT_BLOCK_CRC;\n  return inData;\n}\nvoid BzpInDeComdataFinish(InDeComdata *inData) {\n  if (inData != NULL) {\n    free(inData);\n    inData = NULL;\n  }\n}\n\nuint32_t BzpReadBits(int32_t nBit, InDeComdata *inData) {\n  uint32_t res = 0;\n\n  while (inData->nBuf < nBit) {\n    if (inData->input->nBuf == inData->input->pos) {\n      inData->input->nBuf =\n          fread(inData->input->buf, sizeof(char), sizeof(inData->input->buf),\n                inData->input->filePtr);\n      inData->input->pos = 0;\n    }\n    int32_t data = ((uint32_t)(inData->input->buf[inData->input->pos]));\n\n    inData->buf = (inData->buf << BZP_BITS8) | data;\n    inData->input->pos++;\n    inData->nBuf += BZP_BITS8;\n  }\n  res = inData->buf >> (inData->nBuf - nBit);\n  res = res & ((1 << nBit) - 1);\n  inData->nBuf -= nBit;\n  return res;\n}\n\nint32_t BzpWriteChar(uint8_t ch, InDeComdata *inData) {\n  int32_t ret = BZP_OK;\n  if (inData->output->nBuf >= BZP_BUF_SIZE) {\n    int32_t n2 = fwrite((void *)(inData->output->buf), sizeof(uint8_t),\n                        inData->output->nBuf, inData->output->filePtr);\n    if (n2 != inData->output->nBuf) {\n      ret = BZP_ERROR_IO;\n    }\n    inData->output->nBuf = 0;\n  }\n  inData->output->buf[inData->output->nBuf++] = ch;\n  return ret;\n}\n\nint32_t BzpHuffmanDecodeStep(BzpHuffmanDecode *huffman, InDeComdata *inData) {\n\n  if (huffman->deCodeNum == BZP_ELEMS_NUM_IN_ONE_GROUP) {\n    huffman->deCodeNum = 0;\n    huffman->selectCnt++;\n  }\n  int32_t gid = huffman->select[huffman->selectCnt];\n\n  int32_t chlen = huffman->minLens[gid];\n  int32_t val = BzpReadBits(chlen, inData);\n\n  while (chlen < BZP_HUFFMAN_LEN_UPPER_LIMIT &&\n         val > huffman->limit[gid][chlen]) {\n    chlen++;\n    int32_t nxtbit = BzpReadBits(1, inData);\n    val = (val << 1) | nxtbit;\n  }\n  if (chlen > BZP_HUFFMAN_LEN_UPPER_LIMIT) {\n    return -1;\n  }\n\n  val = val - huffman->base[gid][chlen];\n  val = huffman->perm[gid][val];\n  huffman->deCodeNum++;\n  return val;\n}\n\nint32_t BzpCheckFileHead(InDeComdata *inData) {\n  uint8_t ch;\n  ch = BzpReadBits(BZP_BITS8, inData);\n  if (ch != BZP_BLOCK_HEAD_1) {\n    return BZP_ERROR_DATA;\n  }\n  ch = BzpReadBits(BZP_BITS8, inData);\n  if (ch != BZP_BLOCK_HEAD_2) {\n    return BZP_ERROR_DATA;\n  }\n  ch = BzpReadBits(BZP_BITS8, inData);\n  if (ch != BZP_BLOCK_HEAD_3) {\n    return BZP_ERROR_DATA;\n  }\n  ch = BzpReadBits(BZP_BITS8, inData);\n  if (ch != BZP_BLOCK_HEAD_4) {\n    return BZP_ERROR_DATA;\n  }\n  ch = BzpReadBits(BZP_BITS8, inData);\n  if (ch != BZP_BLOCK_HEAD_5) {\n    return BZP_ERROR_DATA;\n  }\n  return BZP_OK;\n}\n\nuint32_t BzpReadUInt24(InDeComdata *inData) {\n  uint8_t ch;\n  uint32_t val = 0;\n  ch = BzpReadBits(BZP_BITS8, inData);\n  val = (val << BZP_BITS8) | ((uint32_t)ch);\n  ch = BzpReadBits(BZP_BITS8, inData);\n  val = (val << BZP_BITS8) | ((uint32_t)ch);\n  ch = BzpReadBits(BZP_BITS8, inData);\n  val = (val << BZP_BITS8) | ((uint32_t)ch);\n  return val;\n}\n\nuint32_t BzpReadUInt32(InDeComdata *inData) {\n  uint8_t ch;\n  uint32_t val = 0;\n  ch = BzpReadBits(BZP_BITS8, inData);\n  val = (val << BZP_BITS8) | ((uint32_t)ch);\n  ch = BzpReadBits(BZP_BITS8, inData);\n  val = (val << BZP_BITS8) | ((uint32_t)ch);\n  ch = BzpReadBits(BZP_BITS8, inData);\n  val = (val << BZP_BITS8) | ((uint32_t)ch);\n  ch = BzpReadBits(BZP_BITS8, inData);\n  val = (val << BZP_BITS8) | ((uint32_t)ch);\n  return val;\n}\n\nint32_t BzpDeHuffmanSelect(InDeComdata *inData, BzpHuffmanDecode *huffman) {\n  uint8_t ch;\n\n  int32_t selectmtf[BZP_HUFFMAN_MAX_SIZE_SELECT];\n  for (int32_t i = 0; i < huffman->nSelect; i++) {\n    int32_t j = -1;\n    do {\n      ch = BzpReadBits(BZP_BIT, inData);\n      j++;\n    } while (ch != 0);\n    if (j >= huffman->nGroups) {\n      return BZP_ERROR_DATA;\n    }\n    selectmtf[i] = j;\n  }\n\n  int32_t listSelect[BZP_MAX_GROUPS_NUM];\n  for (int32_t i = 0; i < BZP_MAX_GROUPS_NUM; i++) {\n    listSelect[i] = i;\n  }\n\n  for (int32_t i = 0; i < huffman->nSelect; i++) {\n    int32_t pos = selectmtf[i];\n    int32_t tmpv = listSelect[pos];\n    for (int32_t j = pos; j > 0; j--) {\n      listSelect[j] = listSelect[j - 1];\n    }\n    listSelect[0] = tmpv;\n    huffman->select[i] = tmpv;\n  }\n  return BZP_OK;\n}\n\nint32_t BzpDeHuffmanLen(InDeComdata *inData, BzpHuffmanDecode *huffman) {\n  uint8_t ch;\n  for (int32_t i = 0; i < huffman->nGroups; i++) {\n    int32_t val = BzpReadBits(BZP_BITS5, inData);\n    for (int32_t j = 0; j < huffman->alphaSize; j++) {\n\n      ch = BzpReadBits(BZP_BIT, inData);\n      while (ch != 0) {\n        ch = BzpReadBits(BZP_BIT, inData);\n        val += (ch == 0 ? 1 : -1);\n        ch = BzpReadBits(BZP_BIT, inData);\n      }\n      if (val < 1 || val > BZP_HUFFMAN_LEN_UPPER_LIMIT) {\n        return BZP_ERROR_DATA;\n      }\n      huffman->len[i][j] = val;\n    }\n  }\n  return BZP_OK;\n}\n\nint32_t BzpMTFDeCode(InDeComdata *inData, BzpHuffmanDecode *huffman,\n                     BzpBwtDecodeInfo *debwt) {\n  debwt->nBlock = 0;\n  uint8_t ch;\n  int32_t ninUse = huffman->alphaSize - BZP_EXTRA_CHARS_NUM;\n  int32_t eob = ninUse + 1;\n  int32_t val = BzpHuffmanDecodeStep(huffman, inData);\n  while (val != eob && val != -1) {\n    if (val == 0 || val == 1) {\n      int32_t res = 0, basenum = 1;\n      while (val == 0 || val == 1) {\n        res = res + (val + 1) * basenum;\n        basenum <<= 1;\n        val = BzpHuffmanDecodeStep(huffman, inData);\n      }\n      for (int32_t j = 0; j < res; j++) {\n        debwt->block[debwt->nBlock++] = inData->list[0];\n      }\n    } else {\n      int32_t pos = val - 1;\n      ch = inData->list[pos];\n      debwt->block[debwt->nBlock++] = ch;\n\n      for (int32_t j = pos; j > 0; j--) {\n        inData->list[j] = inData->list[j - 1];\n      }\n      inData->list[0] = ch;\n      val = BzpHuffmanDecodeStep(huffman, inData);\n    }\n  }\n  if (val == -1) {\n    return BZP_ERROR_DATA;\n  }\n  return BZP_OK;\n}\nint32_t BzpDeCodeToStream(InDeComdata *inData, BzpBwtDecodeInfo *debwt) {\n  uint8_t ch;\n  int32_t ret = BZP_OK;\n  for (int32_t i = 0; i < debwt->nBlock; i++) {\n    ch = debwt->deCode[i];\n    if (inData->num == BZP_RLC_NUM_4) {\n      for (int32_t j = 0; j < ((int32_t)ch); j++) {\n        BZP_UPDATE_CRC(inData->blockCRC, (uint8_t)inData->lasChar);\n        ret |= BzpWriteChar(inData->lasChar, inData);\n      }\n      inData->lasChar = BZP_ASCII_SIZE;\n      inData->num = 0;\n    } else if (ch == inData->lasChar) {\n      BZP_UPDATE_CRC(inData->blockCRC, ch);\n      ret = BzpWriteChar(ch, inData);\n      inData->num++;\n    } else {\n      BZP_UPDATE_CRC(inData->blockCRC, ch);\n      ret = BzpWriteChar(ch, inData);\n      inData->lasChar = ch;\n      inData->num = 1;\n    }\n    if (ret != BZP_OK)\n      break;\n  }\n  return ret;\n}\n\nint32_t BzpGetDictionaryList(InDeComdata *inData) {\n  int32_t ninUse = 0;\n\n  bool use16[16] = {0};\n  bool inUse[BZP_ASCII_SIZE] = {0};\n  for (int32_t i = 0; i < BZP_GROUPS_ASCII; i++) {\n    use16[i] = BzpReadBits(BZP_BIT, inData);\n  }\n  for (int32_t i = 0; i < BZP_GROUPS_ASCII; i++) {\n    if (use16[i]) {\n      for (int32_t j = 0; j < BZP_CHARS_PER_GROUP_ASCII; j++) {\n        inUse[i * BZP_GROUPS_ASCII + j] = BzpReadBits(BZP_BIT, inData);\n      }\n    }\n  }\n\n  for (int32_t i = 0; i < BZP_ASCII_SIZE; i++) {\n    if (inUse[i]) {\n      inData->list[ninUse++] = i;\n    }\n  }\n  return ninUse;\n}\n\nint32_t BzpDeCompressOneBlock(InDeComdata *inData, BzpHuffmanDecode *huffman,\n                              BzpBwtDecodeInfo *debwt) {\n\n  int32_t ret = BZP_OK;\n  BzpCheckFileHead(inData);\n  uint32_t blockCRC = BzpReadUInt32(inData);\n\n  (void)BzpReadBits(BZP_BIT, inData);\n\n  int32_t oriPtr = BzpReadUInt24(inData);\n  if (oriPtr < 0 || oriPtr > BZP_BASE_BLOCK_SIZE * inData->blockSize) {\n    return BZP_ERROR_DATA;\n  }\n\n  int32_t ninUse = BzpGetDictionaryList(inData);\n  huffman->alphaSize = ninUse + BZP_EXTRA_CHARS_NUM;\n  huffman->nGroups = BzpReadBits(BZP_BITS3, inData);\n  if (huffman->nGroups < BZP_NGROUPS_NUM_0 ||\n      huffman->nGroups > BZP_NGROUPS_NUM_4) {\n    return BZP_ERROR_DATA;\n  }\n  huffman->nSelect = BzpReadBits(BZP_BITS15, inData);\n\n  int32_t nSelectUpperLimit =\n      (inData->blockSize * BZP_BASE_BLOCK_SIZE / BZP_ELEMS_NUM_IN_ONE_GROUP +\n       1);\n  if (huffman->nSelect < 1 || huffman->nSelect > nSelectUpperLimit) {\n    return BZP_ERROR_DATA;\n  }\n\n  ret |= BzpDeHuffmanSelect(inData, huffman);\n\n  ret |= BzpDeHuffmanLen(inData, huffman);\n  if (ret != BZP_OK) {\n    return ret;\n  }\n\n  BzpGenerateDecodeTable(huffman);\n\n  debwt->oriPtr = oriPtr;\n  ret = BzpMTFDeCode(inData, huffman, debwt);\n  if (ret != BZP_OK ||\n      debwt->nBlock >= BZP_BASE_BLOCK_SIZE * inData->blockSize) {\n    return BZP_ERROR_DATA;\n  }\n\n  BzpBwtDecode(debwt);\n\n  ret = BzpDeCodeToStream(inData, debwt);\n  if (ret != BZP_OK) {\n    return ret;\n  }\n  inData->blockCRC = ~(inData->blockCRC);\n\n  if (blockCRC != inData->blockCRC) {\n    ret = BZP_ERROR_DATA;\n  }\n\n  return ret;\n}\n\nint32_t BZPReadFileEnd(InDeComdata *inData, uint32_t caltotalCRC) {\n  uint8_t ch = BzpReadBits(BZP_BITS8, inData);\n  if (ch != BZP_FILE_END_1) {\n    return BZP_ERROR_DATA;\n  }\n  ch = BzpReadBits(BZP_BITS8, inData);\n  if (ch != BZP_FILE_END_2) {\n    return BZP_ERROR_DATA;\n  }\n  ch = BzpReadBits(BZP_BITS8, inData);\n  if (ch != BZP_FILE_END_3) {\n    return BZP_ERROR_DATA;\n  }\n  ch = BzpReadBits(BZP_BITS8, inData);\n  if (ch != BZP_FILE_END_4) {\n    return BZP_ERROR_DATA;\n  }\n  ch = BzpReadBits(BZP_BITS8, inData);\n  if (ch != BZP_FILE_END_5) {\n    return BZP_ERROR_DATA;\n  }\n\n  uint32_t storedcombinedcrc = BzpReadUInt32(inData);\n\n  if (caltotalCRC != storedcombinedcrc) {\n    return BZP_ERROR_DATA;\n  }\n  return BZP_OK;\n}\n\nint32_t BzpReadFileHead(InDeComdata *inData) {\n\n  uint8_t ch = BzpReadBits(BZP_BITS8, inData);\n  if (ch != BZP_HDR_B) {\n    return BZP_ERROR_DATA_MAGIC;\n  }\n  ch = BzpReadBits(BZP_BITS8, inData);\n  if (ch != BZP_HDR_Z) {\n    return BZP_ERROR_DATA_MAGIC;\n  }\n  ch = BzpReadBits(BZP_BITS8, inData);\n  if (ch != BZP_HDR_H) {\n    return BZP_ERROR_DATA_MAGIC;\n  }\n  ch = BzpReadBits(BZP_BITS8, inData);\n  int32_t blockSize = ch - BZP_HDR_0;\n  if (BZP_INVALID_BLOCK_SIZE(blockSize)) {\n    return BZP_ERROR_DATA_MAGIC;\n  }\n\n  inData->blockSize = blockSize;\n  return BZP_OK;\n}\n\nint32_t BZPDeCompressData(InDeComdata *inData) {\n  int32_t ret = BZP_OK;\n  uint32_t caltotalCRC = 0;\n  uint8_t ch;\n  ret = BzpReadFileHead(inData);\n  if (ret != BZP_OK) {\n    return ret;\n  }\n  BzpHuffmanDecode *huffman = BzpHuffmanDecodeInit(inData->blockSize);\n  BzpBwtDecodeInfo *debwt = BzpBwtDecodeInit(inData->blockSize);\n\n  while ((ch = BzpReadBits(BZP_BITS8, inData)) != BZP_FILE_END_0) {\n    if (ch != BZP_BLOCK_HEAD_0) {\n      ret = BZP_ERROR_DATA;\n      break;\n    }\n    BzpHuffmanDecodeReset(huffman);\n    inData->blockCRC = BZP_INIT_BLOCK_CRC;\n\n    ret = BzpDeCompressOneBlock(inData, huffman, debwt);\n    if (ret != BZP_OK) {\n      break;\n    }\n\n    caltotalCRC = (caltotalCRC << 1) | (caltotalCRC >> BZP_CRC_MOVE_RIGHT_VAL);\n    caltotalCRC ^= inData->blockCRC;\n  }\n  if (ret == BZP_OK) {\n    ret = BZPReadFileEnd(inData, caltotalCRC);\n  }\n  BzpHuffmanDecodeFinish(huffman);\n  BzpBwtDecodeFinish(debwt);\n  return ret;\n}\n\nvoid BzpDeComStreamFinish(InDeComdata *inData, BzpStream *inStream,\n                          BzpStream *outStream) {\n\n  if (inStream->filePtr != NULL) {\n    fclose(inStream->filePtr);\n    inStream->filePtr = NULL;\n  }\n  if (outStream->filePtr != NULL) {\n    fclose(outStream->filePtr);\n    outStream->filePtr = NULL;\n  }\n  BzpStreamFinish(inStream);\n  BzpStreamFinish(outStream);\n  BzpInDeComdataFinish(inData);\n}\n\nint32_t BzpDeCompressStream(char *inName, char *outName) {\n  int32_t ret = BZP_OK;\n  if (inName == NULL || outName == NULL) {\n    return BZP_ERROR_PARAM;\n  }\n\n  BzpStream *inStream = BzpStreamInit();\n  BzpStream *outStream = BzpStreamInit();\n  if (inStream == NULL || outStream == NULL) {\n    BzpStreamFinish(inStream);\n    BzpStreamFinish(outStream);\n    return BZP_ERROR_MEMORY_OPER_FAILURE;\n  }\n  inStream->filePtr = fopen(inName, \"rb\");\n  outStream->filePtr = fopen(outName, \"wb\");\n  if ((inStream->filePtr == NULL || outStream->filePtr == NULL)) {\n    free(inStream);\n    inStream = NULL;\n    free(outStream);\n    outStream = NULL;\n    remove(outName);\n    return BZP_ERROR_IO;\n  }\n  InDeComdata *inData = BzpInDeComdataInit();\n  if (inData == NULL) {\n    BzpDeComStreamFinish(inData, inStream, outStream);\n    remove(outName);\n    return BZP_ERROR_MEMORY_OPER_FAILURE;\n  }\n  inData->input = inStream;\n  inData->output = outStream;\n\n  ret = BZPDeCompressData(inData);\n\n  if (inData->output->nBuf > 0) {\n    int32_t n2 = fwrite((void *)(inData->output->buf), sizeof(uint8_t),\n                        inData->output->nBuf, inData->output->filePtr);\n    if (n2 != inData->output->nBuf) {\n      ret = BZP_ERROR_IO;\n    }\n    inData->output->nBuf = 0;\n  }\n\n  BzpDeComStreamFinish(inData, inStream, outStream);\n  if (ret != BZP_OK) {\n    remove(outName);\n  }\n  return ret;\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
    "src/decompress/bzp_bwt_decode.c": "# 1 \".tmp/src/decompress/bzp_bwt_decode.c\"\n# 17 \".tmp/src/decompress/bzp_bwt_decode.c\"\n#include \"bzp_bwt_decode.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nBzpBwtDecodeInfo *BzpBwtDecodeInit(int32_t blockSize) {\n  if (BZP_INVALID_BLOCK_SIZE(blockSize)) {\n    return NULL;\n  }\n  BzpBwtDecodeInfo *bwt = (BzpBwtDecodeInfo *)malloc(sizeof(BzpBwtDecodeInfo));\n  if (bwt == NULL) {\n    return NULL;\n  }\n  int32_t spaceSize = BZP_BASE_BLOCK_SIZE * blockSize;\n  bwt->block = (uint8_t *)malloc(spaceSize * sizeof(uint8_t));\n  bwt->deCode = (uint8_t *)malloc(spaceSize * sizeof(uint8_t));\n  bwt->sorted = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n  if (bwt->block == NULL || bwt->sorted == NULL || bwt->deCode == NULL) {\n    BzpBwtDecodeFinish(bwt);\n    return NULL;\n  }\n  bwt->nBlock = 0;\n  bwt->oriPtr = 0;\n  return bwt;\n}\n\nvoid BzpBwtDecode(BzpBwtDecodeInfo *bwt) {\n\n  int32_t ftab[257];\n  (void)memset_s(ftab, sizeof(ftab), 0, sizeof(ftab));\n  for (int32_t i = 0; i < bwt->nBlock; i++) {\n    ftab[bwt->block[i] + 1]++;\n  }\n  for (int32_t i = 1; i <= BZP_ASCII_SIZE; i++) {\n    ftab[i] += ftab[i - 1];\n  }\n  for (int32_t i = 0; i < bwt->nBlock; i++) {\n    uint8_t ch = bwt->block[i];\n    bwt->sorted[ftab[ch]] = i;\n    ftab[ch]++;\n  }\n  int32_t cnt = 0;\n  int32_t pos = bwt->oriPtr;\n  while (cnt < bwt->nBlock) {\n    pos = bwt->sorted[pos];\n    uint8_t ch = bwt->block[pos];\n    bwt->deCode[cnt] = ch;\n    cnt++;\n  }\n}\n\nvoid BzpBwtDecodeFinish(BzpBwtDecodeInfo *bwt) {\n  if (bwt != NULL) {\n    if (bwt->block != NULL) {\n      free(bwt->block);\n      bwt->block = NULL;\n    }\n    if (bwt->deCode != NULL) {\n      free(bwt->deCode);\n      bwt->deCode = NULL;\n    }\n    if (bwt->sorted != NULL) {\n      free(bwt->sorted);\n      bwt->sorted = NULL;\n    }\n    free(bwt);\n    bwt = NULL;\n  }\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
    "src/decompress/bzp_huffman_decode.h": "# 1 \".tmp/src/decompress/bzp_huffman_decode.h\"\n# 17 \".tmp/src/decompress/bzp_huffman_decode.h\"\n#ifndef BZP_HUFFMAN_DECODE_H\n#define BZP_HUFFMAN_DECODE_H\n\n#include \"bzp_utils.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n  int32_t *select;\n  int32_t len[BZP_MAX_GROUPS_NUM][BZP_MAX_ALPHA_SIZE];\n  int32_t perm[BZP_MAX_GROUPS_NUM][BZP_MAX_ALPHA_SIZE];\n  int32_t limit[BZP_MAX_GROUPS_NUM][BZP_MAX_ALPHA_SIZE];\n  int32_t base[BZP_MAX_GROUPS_NUM][BZP_MAX_ALPHA_SIZE];\n  int32_t minLens[BZP_MAX_GROUPS_NUM];\n  int32_t nGroups;\n  int32_t nSelect;\n  int32_t alphaSize;\n  int32_t deCodeNum;\n  int32_t selectCnt;\n  int32_t nBlock;\n} BzpHuffmanDecode;\n\nBzpHuffmanDecode *BzpHuffmanDecodeInit(int32_t blockSize);\n\nvoid BzpGetOneTable(BzpHuffmanDecode *huffman, int32_t t);\n\nvoid BzpGenerateDecodeTable(BzpHuffmanDecode *huffman);\n\nvoid BzpHuffmanDecodeFinish(BzpHuffmanDecode *huffman);\n\nvoid BzpHuffmanDecodeReset(BzpHuffmanDecode *huffman);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
    "src/decompress/bzp_bwt_decode.h": "# 1 \".tmp/src/decompress/bzp_bwt_decode.h\"\n# 17 \".tmp/src/decompress/bzp_bwt_decode.h\"\n#ifndef BZP_BWT_DECODE_H\n#define BZP_BWT_DECODE_H\n\n#include \"bzp_utils.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n  int32_t *sorted;\n  uint8_t *block;\n  uint8_t *deCode;\n  int32_t nBlock;\n  int32_t oriPtr;\n} BzpBwtDecodeInfo;\n\nBzpBwtDecodeInfo *BzpBwtDecodeInit(int32_t blockSize);\n\nvoid BzpBwtDecode(BzpBwtDecodeInfo *bwt);\n\nvoid BzpBwtDecodeFinish(BzpBwtDecodeInfo *bwt);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
    "src/decompress/bzp_huffman_decode.c": "# 1 \".tmp/src/decompress/bzp_huffman_decode.c\"\n# 17 \".tmp/src/decompress/bzp_huffman_decode.c\"\n#include \"bzp_huffman_decode.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nBzpHuffmanDecode *BzpHuffmanDecodeInit(int32_t blockSize) {\n  if (BZP_INVALID_BLOCK_SIZE(blockSize)) {\n    return NULL;\n  }\n  BzpHuffmanDecode *huffman =\n      (BzpHuffmanDecode *)malloc(sizeof(BzpHuffmanDecode));\n  if (huffman == NULL) {\n    return NULL;\n  }\n  int32_t spaceSize =\n      BZP_BASE_BLOCK_SIZE * blockSize / BZP_ELEMS_NUM_IN_ONE_GROUP;\n  huffman->select = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n  if (huffman->select == NULL) {\n    BzpHuffmanDecodeFinish(huffman);\n  }\n\n  (void)memset_s(huffman->base, sizeof(huffman->base), 0,\n                 sizeof(huffman->base));\n  (void)memset_s(huffman->perm, sizeof(huffman->perm), 0,\n                 sizeof(huffman->perm));\n  (void)memset_s(huffman->limit, sizeof(huffman->limit), 0,\n                 sizeof(huffman->limit));\n\n  huffman->selectCnt = 0;\n  huffman->deCodeNum = 0;\n  return huffman;\n}\n\nvoid BzpHuffmanDecodeReset(BzpHuffmanDecode *huffman) {\n  (void)memset_s(huffman->base, sizeof(huffman->base), 0,\n                 sizeof(huffman->base));\n  (void)memset_s(huffman->perm, sizeof(huffman->perm), 0,\n                 sizeof(huffman->perm));\n  (void)memset_s(huffman->limit, sizeof(huffman->limit), 0,\n                 sizeof(huffman->limit));\n\n  huffman->selectCnt = 0;\n  huffman->deCodeNum = 0;\n}\n\nvoid BzpGetOneTable(BzpHuffmanDecode *huffman, int32_t t) {\n  int32_t vec = 0, cnt = 0;\n  int32_t mi = huffman->len[t][0], mx = huffman->len[t][0];\n  for (int32_t i = 0; i < huffman->alphaSize; i++) {\n    mi = BZP_MIN_FUN(mi, huffman->len[t][i]);\n    mx = BZP_MAX_FUN(mx, huffman->len[t][i]);\n  }\n  huffman->minLens[t] = mi;\n  for (int32_t i = mi; i <= mx; i++) {\n    for (int32_t j = 0; j < huffman->alphaSize; j++) {\n      if (huffman->len[t][j] == i) {\n        huffman->perm[t][cnt++] = j;\n      }\n    }\n  }\n  for (int32_t i = 0; i < huffman->alphaSize; i++) {\n    huffman->base[t][huffman->len[t][i] + 1]++;\n  }\n\n  for (int32_t i = 1; i <= mx + 1; i++) {\n    huffman->base[t][i] += huffman->base[t][i - 1];\n  }\n\n  for (int32_t i = mi; i <= mx; i++) {\n\n    vec += (huffman->base[t][i + 1] - huffman->base[t][i]);\n\n    huffman->limit[t][i] = vec - 1;\n    vec <<= 1;\n  }\n  for (int32_t i = mi + 1; i <= mx; i++) {\n    huffman->base[t][i] =\n        ((huffman->limit[t][i - 1] + 1) << 1) - huffman->base[t][i];\n  }\n}\n\nvoid BzpGenerateDecodeTable(BzpHuffmanDecode *huffman) {\n  for (int32_t t = 0; t < huffman->nGroups; t++) {\n    BzpGetOneTable(huffman, t);\n  }\n}\n\nvoid BzpHuffmanDecodeFinish(BzpHuffmanDecode *huffman) {\n  if (huffman != NULL) {\n    if (huffman->select != NULL) {\n      free(huffman->select);\n      huffman->select = NULL;\n    }\n\n    free(huffman);\n    huffman = NULL;\n  }\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
    "src/compress/bzp_bwt_encode.h": "# 1 \".tmp/src/compress/bzp_bwt_encode.h\"\n# 17 \".tmp/src/compress/bzp_bwt_encode.h\"\n#ifndef BZP_BWT_ENCODE_H\n#define BZP_BWT_ENCODE_H\n\n#include \"bzp_utils.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n  int32_t *sortBlock;\n  int32_t *idx;\n  int32_t *isStartPos;\n  uint8_t *block;\n  uint32_t blockCRC;\n  uint32_t combinedCRC;\n  int32_t nBlockMax;\n  int32_t blockId;\n  int32_t nBlock;\n  int32_t oriPtr;\n  bool inUse[BZP_ASCII_SIZE];\n} BzpBwtInfo;\n\nBzpBwtInfo *BzpBlockSortInit(int32_t blockSize);\n\nvoid BzpShellSort(int32_t *sortBlock, int32_t *idx, int32_t l, int32_t r);\n\nvoid BzpSwap2Elem(int32_t *sortBlock, int32_t lPos, int32_t rPos);\n\nvoid BzpSwap3Elem(int32_t *sortBlock, int32_t lPos, int32_t ePos, int32_t rPos);\n\nint32_t BzpSelectMidVal(int32_t *sortBlock, int32_t *idx, int32_t l, int32_t r);\n\nvoid BzpQuickSort(int32_t *sortBlock, int32_t *idx, int32_t l, int32_t r);\n\nvoid BzpBinaryLiftingSort(BzpBwtInfo *bwt);\n\nvoid BzpBlockSortMain(BzpBwtInfo *bwt);\n\nvoid BzpBwtFinish(BzpBwtInfo *bwt);\n\nvoid BzpUpdateflag(BzpBwtInfo *bwt, int32_t l, int32_t r);\n\ntypedef struct {\n  int32_t stackL[BZP_MAX_STACK_SIZE];\n  int32_t stackR[BZP_MAX_STACK_SIZE];\n  int32_t cnt;\n  int32_t tl, tr;\n} BzpQSortInfo;\n\nvoid BzpQSortSingle(int32_t *sortBlock, int32_t *idx, BzpQSortInfo *stack);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
    "src/compress/bzp_mtf_encode.h": "# 1 \".tmp/src/compress/bzp_mtf_encode.h\"\n# 17 \".tmp/src/compress/bzp_mtf_encode.h\"\n#ifndef BZP_MTF_ENCODE_H\n#define BZP_MTF_ENCODE_H\n\n#include \"bzp_utils.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n  uint8_t *block;\n  int32_t *map;\n  int32_t *mtfV;\n  bool *inUse;\n  int32_t mtfFreq[BZP_MAX_ALPHA_SIZE];\n  int32_t nBlock;\n  int32_t nMtf;\n  int32_t nUse;\n  int32_t pad;\n} BzpMtfInfo;\n\nBzpMtfInfo *BzpMtfInit(int32_t blockSize);\n\nvoid BzpMapInputChar(BzpMtfInfo *mtf, uint8_t *list, int32_t lenList);\n\nvoid BzpNumEncode(BzpMtfInfo *mtf, int32_t num);\n\nvoid BzpMtfMain(BzpMtfInfo *mtf);\n\nvoid BzpMtfFinish(BzpMtfInfo *mtf);\n\nvoid BzpMtfReSet(BzpMtfInfo *mtf);\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
    "src/compress/bzp_mtf_encode.c": "# 1 \".tmp/src/compress/bzp_mtf_encode.c\"\n# 17 \".tmp/src/compress/bzp_mtf_encode.c\"\n#include \"bzp_mtf_encode.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nBzpMtfInfo *BzpMtfInit(int32_t blockSize) {\n  if (BZP_INVALID_BLOCK_SIZE(blockSize)) {\n    return NULL;\n  }\n  BzpMtfInfo *mtf = (BzpMtfInfo *)malloc(sizeof(BzpMtfInfo));\n  if (mtf == NULL) {\n    return NULL;\n  }\n  mtf->mtfV = NULL;\n  mtf->mtfV =\n      (int32_t *)malloc(blockSize * BZP_BASE_BLOCK_SIZE * sizeof(int32_t));\n  if (mtf->mtfV == NULL) {\n    free(mtf);\n    mtf = NULL;\n    return NULL;\n  }\n\n  mtf->nUse = 0;\n  mtf->nMtf = 0;\n  mtf->block = NULL;\n  mtf->map = NULL;\n  mtf->inUse = NULL;\n  return mtf;\n}\n\nvoid BzpMtfReSet(BzpMtfInfo *mtf) {\n\n  mtf->nUse = 0;\n  mtf->nMtf = 0;\n  mtf->block = NULL;\n  mtf->map = NULL;\n  mtf->inUse = NULL;\n}\n\nvoid BzpMapInputChar(BzpMtfInfo *mtf, uint8_t *list, int32_t lenList) {\n  if (BZP_ASCII_SIZE > lenList) {\n    return;\n  }\n  for (int32_t i = 0; i < BZP_ASCII_SIZE; i++) {\n    if (mtf->inUse[i]) {\n      list[mtf->nUse] = (uint8_t)i;\n      mtf->nUse++;\n    }\n  }\n}\n\nvoid BzpNumEncode(BzpMtfInfo *mtf, int32_t num) {\n  num <<= 1;\n\n  do {\n    num >>= 1;\n    num--;\n    if (num & 1) {\n      mtf->mtfV[mtf->nMtf++] = BZP_MTF_ENCODE1;\n      mtf->mtfFreq[BZP_MTF_ENCODE1]++;\n    } else {\n      mtf->mtfV[mtf->nMtf++] = BZP_MTF_ENCODE0;\n      mtf->mtfFreq[BZP_MTF_ENCODE0]++;\n    }\n  } while (num >= BZP_MTF_ENCODE_BASE);\n}\n\nvoid BzpMtfMain(BzpMtfInfo *mtf) {\n  uint8_t list[BZP_MAX_ALPHA_SIZE];\n  int32_t EOB;\n  int32_t num = 0;\n  BzpMapInputChar(mtf, list, BZP_MAX_ALPHA_SIZE);\n  EOB = mtf->nUse + 1;\n  for (int32_t i = 0; i <= EOB; i++) {\n    mtf->mtfFreq[i] = 0;\n  }\n  for (int32_t i = 0; i < mtf->nBlock; i++) {\n    int32_t pos = mtf->map[i] - 1;\n    if (pos < 0) {\n      pos += mtf->nBlock;\n    }\n    uint8_t ch = mtf->block[pos];\n    if (ch == list[0]) {\n      num++;\n    } else {\n      if (num > 0) {\n        BzpNumEncode(mtf, num);\n        num = 0;\n      }\n      int32_t pos_ = 1;\n      while (ch != list[pos_] && pos_ < mtf->nUse) {\n        pos_++;\n      }\n\n      for (int32_t j = pos_; j > 0; j--) {\n        list[j] = list[j - 1];\n      }\n      list[0] = ch;\n\n      mtf->mtfV[mtf->nMtf] = pos_ + 1;\n      mtf->mtfFreq[pos_ + 1]++;\n      mtf->nMtf++;\n    }\n  }\n  if (num > 0) {\n    BzpNumEncode(mtf, num);\n  }\n\n  mtf->mtfV[mtf->nMtf] = EOB;\n  mtf->mtfFreq[EOB]++;\n  mtf->nMtf++;\n}\n\nvoid BzpMtfFinish(BzpMtfInfo *mtf) {\n  if (mtf != NULL) {\n    if (mtf->mtfV != NULL) {\n      free(mtf->mtfV);\n      mtf->mtfV = NULL;\n    }\n    free(mtf);\n    mtf = NULL;\n  }\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
    "src/compress/bzp_bwt_encode.c": "# 1 \".tmp/src/compress/bzp_bwt_encode.c\"\n# 18 \".tmp/src/compress/bzp_bwt_encode.c\"\n#include \"bzp_bwt_encode.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nBzpBwtInfo *BzpBlockSortInit(int32_t blockSize) {\n  if (BZP_INVALID_BLOCK_SIZE(blockSize)) {\n    return NULL;\n  }\n  BzpBwtInfo *bwt = (BzpBwtInfo *)malloc(sizeof(BzpBwtInfo));\n  if (bwt == NULL) {\n    return NULL;\n  }\n\n  (void)memset_s(bwt, sizeof(BzpBwtInfo), 0, sizeof(BzpBwtInfo));\n\n  int32_t spaceSize = blockSize * BZP_BASE_BLOCK_SIZE;\n  bwt->nBlockMax = spaceSize - BZP_BLOCK_RESERVED_SPACE_SIZE;\n  bwt->block = (uint8_t *)malloc(spaceSize * sizeof(uint8_t));\n  bwt->sortBlock = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n  bwt->idx = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n  bwt->isStartPos = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n  if (bwt->block == NULL || bwt->sortBlock == NULL || bwt->idx == NULL ||\n      bwt->isStartPos == NULL) {\n    BzpBwtFinish(bwt);\n    return NULL;\n  }\n\n  (void)memset_s(bwt->isStartPos, spaceSize * sizeof(int32_t), 0,\n                 spaceSize * sizeof(int32_t));\n  bwt->blockCRC = BZP_INIT_BLOCK_CRC;\n  return bwt;\n}\n\nvoid BzpShellSort(int32_t *sortBlock, int32_t *idx, int32_t l, int32_t r) {\n\n  int32_t increments[] = {BZP_SHELL_SORT_INCREMENT1, BZP_SHELL_SORT_INCREMENT0};\n  int32_t i, j;\n  if (l >= r) {\n    return;\n  }\n\n  for (int32_t id = 0; id < BZP_SHELL_SORT_INCREMENT_NUMS; id++) {\n    int32_t H = increments[id];\n    if (r - l + 1 <= H) {\n      continue;\n    }\n    for (i = l + H; i <= r; i++) {\n      int32_t tmpIdx = sortBlock[i];\n      int32_t tmpVal = idx[tmpIdx];\n      for (j = i - H; j >= l && idx[sortBlock[j]] > tmpVal; j -= H) {\n        sortBlock[j + H] = sortBlock[j];\n      }\n      sortBlock[j + H] = tmpIdx;\n    }\n  }\n}\n\nvoid BzpSwap2Elem(int32_t *sortBlock, int32_t lPos, int32_t rPos) {\n  int32_t value = sortBlock[lPos];\n  sortBlock[lPos] = sortBlock[rPos];\n  sortBlock[rPos] = value;\n}\n\nvoid BzpSwap3Elem(int32_t *sortBlock, int32_t lPos, int32_t ePos,\n                  int32_t rPos) {\n\n  int32_t value = sortBlock[lPos];\n  sortBlock[lPos] = sortBlock[rPos];\n  sortBlock[rPos] = sortBlock[ePos];\n  sortBlock[ePos] = value;\n}\n\nint32_t BzpSelectMidVal(int32_t *sortBlock, int32_t *idx, int32_t l,\n                        int32_t r) {\n  int32_t mid = (l + r) >> 1;\n  int32_t vl = idx[sortBlock[l]];\n  int32_t vmid = idx[sortBlock[mid]];\n  int32_t vr = idx[sortBlock[r]];\n  if (vl > vr) {\n    int32_t tmp = l;\n    l = r;\n    r = tmp;\n    vl = idx[sortBlock[l]];\n    vr = idx[sortBlock[r]];\n  }\n  if (vmid <= vl) {\n    return vl;\n  } else if (vmid <= vr) {\n    return vmid;\n  } else {\n    return vr;\n  }\n}\n\nvoid BzpQSortSingle(int32_t *sortBlock, int32_t *idx, BzpQSortInfo *stack) {\n  int32_t tl = stack->tl, tr = stack->tr;\n  int32_t value = BzpSelectMidVal(sortBlock, idx, tl, tr);\n  int32_t lPos = tl, rPos = tr, ePos = tl;\n\n  while (ePos <= rPos) {\n    if (idx[sortBlock[ePos]] < value) {\n      BzpSwap2Elem(sortBlock, ePos, lPos);\n      ePos++;\n      lPos++;\n    } else if (idx[sortBlock[ePos]] == value) {\n      ePos++;\n    } else {\n      while (rPos >= ePos && idx[sortBlock[rPos]] > value) {\n        rPos--;\n      }\n      if (rPos < ePos) {\n        break;\n      }\n      if (idx[sortBlock[rPos]] == value) {\n        BzpSwap2Elem(sortBlock, ePos, rPos);\n      } else if (lPos == ePos) {\n\n        BzpSwap2Elem(sortBlock, ePos, rPos);\n        lPos++;\n      } else {\n        BzpSwap3Elem(sortBlock, lPos, ePos, rPos);\n        lPos++;\n      }\n      ePos++;\n      rPos--;\n    }\n  }\n\n  if (lPos - tl > tr - rPos) {\n    stack->stackL[stack->cnt] = tl;\n    stack->stackR[stack->cnt] = lPos - 1;\n    stack->cnt++;\n    stack->stackL[stack->cnt] = rPos + 1;\n    stack->stackR[stack->cnt] = tr;\n    stack->cnt++;\n  } else {\n    stack->stackL[stack->cnt] = rPos + 1;\n    stack->stackR[stack->cnt] = tr;\n    stack->cnt++;\n    stack->stackL[stack->cnt] = tl;\n    stack->stackR[stack->cnt] = lPos - 1;\n    stack->cnt++;\n  }\n}\n\nvoid BzpQuickSort(int32_t *sortBlock, int32_t *idx, int32_t l, int32_t r) {\n  BzpQSortInfo stack;\n  stack.cnt = 0;\n  stack.stackL[stack.cnt] = l;\n  stack.stackR[stack.cnt] = r;\n  stack.cnt++;\n  while (stack.cnt > 0) {\n    stack.cnt--;\n    int32_t tl = stack.stackL[stack.cnt];\n    int32_t tr = stack.stackR[stack.cnt];\n\n    if (tl >= tr) {\n      continue;\n    }\n    if (tr - tl < BZP_THRESHOLD_SHELL_SORT) {\n      BzpShellSort(sortBlock, idx, tl, tr);\n      continue;\n    }\n    stack.tl = tl;\n    stack.tr = tr;\n    BzpQSortSingle(sortBlock, idx, &stack);\n  }\n}\n\nvoid BzpUpdateflag(BzpBwtInfo *bwt, int32_t l, int32_t r) {\n  int32_t tmpst = -1;\n  for (int32_t i = l; i <= r; i++) {\n    int32_t tmpnow = bwt->idx[bwt->sortBlock[i]];\n    if (tmpst != tmpnow) {\n      bwt->isStartPos[i] = 1;\n      tmpst = tmpnow;\n    }\n  }\n}\n\nvoid BzpBinaryLiftingSort(BzpBwtInfo *bwt) {\n  int32_t ftab[BZP_ASCII_SIZE];\n  (void)memset_s(ftab, sizeof(ftab), 0, sizeof(ftab));\n  for (int32_t i = 0; i < bwt->nBlock; i++) {\n    ftab[bwt->block[i]]++;\n  }\n  for (int32_t i = 1; i < BZP_ASCII_SIZE; i++) {\n    ftab[i] += ftab[i - 1];\n  }\n  for (int32_t i = 0; i < bwt->nBlock; i++) {\n    int32_t ch = bwt->block[i];\n    ftab[ch]--;\n    bwt->sortBlock[ftab[ch]] = i;\n  }\n  for (int32_t i = 0; i < BZP_ASCII_SIZE; i++) {\n    bwt->isStartPos[ftab[i]] = 1;\n  }\n  int32_t M = 1, sortflag = true;\n\n  while (M < bwt->nBlock && sortflag == true) {\n    int32_t st = 0;\n    sortflag = false;\n\n    for (int32_t i = 0; i < bwt->nBlock; i++) {\n      if (bwt->isStartPos[i]) {\n        st = i;\n      }\n      int32_t pos = bwt->sortBlock[i] - M;\n      if (pos < 0) {\n        pos += bwt->nBlock;\n      }\n      bwt->idx[pos] = st;\n    }\n    int32_t l = 0, r = 1;\n    while (l < bwt->nBlock) {\n      while (r < bwt->nBlock && bwt->isStartPos[r] != 1) {\n        r++;\n      }\n      r--;\n      if (l < r) {\n        sortflag = true;\n        BzpQuickSort(bwt->sortBlock, bwt->idx, l, r);\n        BzpUpdateflag(bwt, l, r);\n      }\n      l = r + 1;\n      r = l + 1;\n    }\n    M <<= 1;\n  }\n}\n\nvoid BzpBlockSortMain(BzpBwtInfo *bwt) {\n  BzpBinaryLiftingSort(bwt);\n\n  for (int32_t i = 0; i < bwt->nBlock; i++) {\n    if (bwt->sortBlock[i] == 0) {\n      bwt->oriPtr = i;\n      break;\n    }\n  }\n}\n\nvoid BzpBwtFinish(BzpBwtInfo *bwt) {\n  if (bwt != NULL) {\n    if (bwt->block != NULL) {\n      free(bwt->block);\n      bwt->block = NULL;\n    }\n    if (bwt->sortBlock != NULL) {\n      free(bwt->sortBlock);\n      bwt->sortBlock = NULL;\n    }\n    if (bwt->idx != NULL) {\n      free(bwt->idx);\n      bwt->idx = NULL;\n    }\n    if (bwt->isStartPos != NULL) {\n      free(bwt->isStartPos);\n      bwt->isStartPos = NULL;\n    }\n\n    free(bwt);\n    bwt = NULL;\n  }\n}\n\n#ifdef __cplusplus\n}\n#endif\n",
    "src/compress/bzp_huffman_encode.h": "# 1 \".tmp/src/compress/bzp_huffman_encode.h\"\n# 17 \".tmp/src/compress/bzp_huffman_encode.h\"\n#ifndef BZP_HUFFMAN_ENCODE_H\n#define BZP_HUFFMAN_ENCODE_H\n\n#include \"bzp_utils.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n  int32_t heap[BZP_MAX_ALPHA_SIZE + 1];\n  int32_t weight[BZP_MAX_ALPHA_SIZE * 2];\n  int32_t parent[BZP_MAX_ALPHA_SIZE * 2];\n  int32_t len[BZP_MAX_ALPHA_SIZE];\n  int32_t table[BZP_MAX_ALPHA_SIZE];\n  int32_t nHeap;\n  int32_t nWeight;\n  int32_t alphaSize;\n} BzpHuffmanInfo;\n\nvoid BzpHuffmanInit(int32_t alphaSize, BzpHuffmanInfo *huffman);\n\nvoid BzpHuffmanInitArray(BzpHuffmanInfo *huffman);\n\nvoid BzpHeapAdjustUp(int32_t *heap, int32_t *weight, int32_t pos);\n\nvoid BzpHeapAdjustDown(int32_t *heap, int32_t *weight, int32_t nHeap);\n\nvoid BzpHeapInit(BzpHuffmanInfo *huffman);\n\nint32_t BzpHuffmanWeightAdd(int32_t w1, int32_t w2);\n\nvoid BzpBuildHuffmanTree(BzpHuffmanInfo *huffman);\n\nint32_t BzpGetCodeLen(BzpHuffmanInfo *huffman);\n\nvoid BzpBuildTreeBalanceHeight(BzpHuffmanInfo *huffman);\n\nvoid BzpGetHuffmanTable(BzpHuffmanInfo *huffman);\n\nint32_t BzpGetHuffmanGroups(int32_t nBlock);\n\ntypedef struct {\n  int32_t *block;\n  int32_t *mtfFreq;\n  int32_t *select;\n  int32_t *selectMTF;\n  BzpHuffmanInfo huffmanGroups[BZP_MAX_GROUPS_NUM];\n  int32_t cost[BZP_MAX_GROUPS_NUM];\n  int32_t nGroups;\n  int32_t nBlock;\n  int32_t nSelect;\n  int32_t alphaSize;\n} BzpHuffmanGroups;\n\nBzpHuffmanGroups *BzpHuffmanGroupsInit(int32_t blockSize);\n\nvoid BzpHuffmanMain(BzpHuffmanGroups *huffman);\n\nvoid BzpBzpHuffmanGroupsFinish(BzpHuffmanGroups *huffman);\n\nvoid BzpGenerateSelectMTF(BzpHuffmanGroups *huffman);\n\nvoid BzpInitLenArray(BzpHuffmanGroups *huffman);\n\nvoid BzpCalculateCost(BzpHuffmanGroups *huffman, int32_t st, int32_t ed);\n\nint32_t BzpSelectTree(BzpHuffmanGroups *huffman);\n\nint32_t BzpHuffmanGroupsReset(BzpHuffmanGroups *huffman, int32_t alphaSize);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n",
    "src/compress/bzp_huffman_encode.c": "# 1 \".tmp/src/compress/bzp_huffman_encode.c\"\n# 17 \".tmp/src/compress/bzp_huffman_encode.c\"\n#include \"bzp_huffman_encode.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid BzpHuffmanInit(int32_t alphaSize, BzpHuffmanInfo *huffman) {\n  (void)memset_s(huffman->len, sizeof(huffman->len), 0, sizeof(huffman->len));\n  huffman->nHeap = 0;\n  huffman->nWeight = 0;\n  huffman->alphaSize = alphaSize;\n}\n\nvoid BzpHuffmanInitArray(BzpHuffmanInfo *huffman) {\n  int32_t i;\n  huffman->nHeap = 0;\n  huffman->nWeight = huffman->alphaSize;\n\n  for (i = 0; i < huffman->alphaSize; i++) {\n    huffman->parent[i] = -1;\n  }\n}\n\nvoid BzpHeapAdjustUp(int32_t *heap, int32_t *weight, int32_t pos) {\n  int32_t tmpw = weight[heap[pos]];\n  int32_t tmpv = heap[pos];\n  while (pos > 1) {\n    if (tmpw < weight[heap[pos >> 1]]) {\n      heap[pos] = heap[pos >> 1];\n      pos >>= 1;\n    } else {\n      break;\n    }\n  }\n  heap[pos] = tmpv;\n}\n\nvoid BzpHeapAdjustDown(int32_t *heap, int32_t *weight, int32_t nHeap) {\n  int32_t pos = 1;\n  int32_t chpos = pos << 1;\n  int32_t tmpid = heap[pos];\n  int32_t tmpv = weight[tmpid];\n  while (chpos <= nHeap) {\n    if ((chpos | 1) <= nHeap && weight[heap[chpos]] > weight[heap[chpos | 1]]) {\n      chpos |= 1;\n    }\n    if (tmpv < weight[heap[chpos]]) {\n      break;\n    }\n    heap[pos] = heap[chpos];\n    pos = chpos;\n    chpos = pos << 1;\n  }\n  heap[pos] = tmpid;\n}\n\nvoid BzpHeapInit(BzpHuffmanInfo *huffman) {\n  int32_t i = 0;\n  for (i = 0; i < huffman->alphaSize; i++) {\n    huffman->nHeap++;\n    huffman->heap[huffman->nHeap] = i;\n    BzpHeapAdjustUp(huffman->heap, huffman->weight, huffman->nHeap);\n  }\n}\n\nint32_t BzpHuffmanWeightAdd(int32_t w1, int32_t w2) {\n  return ((w1 & 0xffffff00) + (w2 & 0xffffff00)) |\n         (BZP_MAX_FUN((w1 & 0x000000ff), (w2 & 0x000000ff)) + 1);\n}\n\nvoid BzpBuildHuffmanTree(BzpHuffmanInfo *huffman) {\n  BzpHuffmanInitArray(huffman);\n  BzpHeapInit(huffman);\n  int32_t idx1, idx2;\n  while (huffman->nHeap > 1) {\n    idx1 = huffman->heap[1];\n    huffman->heap[1] = huffman->heap[huffman->nHeap--];\n    BzpHeapAdjustDown(huffman->heap, huffman->weight, huffman->nHeap);\n    idx2 = huffman->heap[1];\n    huffman->heap[1] = huffman->heap[huffman->nHeap--];\n    BzpHeapAdjustDown(huffman->heap, huffman->weight, huffman->nHeap);\n    huffman->weight[huffman->nWeight] =\n        BzpHuffmanWeightAdd(huffman->weight[idx1], huffman->weight[idx2]);\n    huffman->parent[idx1] = huffman->nWeight;\n    huffman->parent[idx2] = huffman->nWeight;\n    huffman->parent[huffman->nWeight] = -1;\n    huffman->nHeap++;\n    huffman->heap[huffman->nHeap] = huffman->nWeight;\n    huffman->nWeight++;\n    BzpHeapAdjustUp(huffman->heap, huffman->weight, huffman->nHeap);\n  }\n}\n\nint32_t BzpGetCodeLen(BzpHuffmanInfo *huffman) {\n  int32_t maxlen = 0;\n\n  BzpBuildHuffmanTree(huffman);\n  int32_t i;\n  maxlen = 0;\n  for (i = 0; i < huffman->alphaSize; i++) {\n    int32_t x = i;\n    int32_t tlen = 0;\n    while (huffman->parent[x] >= 0) {\n      x = huffman->parent[x];\n      tlen++;\n    }\n    huffman->len[i] = tlen;\n    maxlen = BZP_MAX_FUN(maxlen, tlen);\n  }\n\n  return maxlen;\n}\n\nvoid BzpBuildTreeBalanceHeight(BzpHuffmanInfo *huffman) {\n  int32_t maxlen = 0;\n  for (int32_t i = 0; i < huffman->alphaSize; i++) {\n    if (huffman->weight[i] == 0) {\n      huffman->weight[i] = 1 << BZP_HUFFMAN_HEIGHT_WEIGHT_BITS;\n    } else {\n      huffman->weight[i] <<= BZP_HUFFMAN_HEIGHT_WEIGHT_BITS;\n    }\n  }\n\n  do {\n    maxlen = BzpGetCodeLen(huffman);\n\n    if (maxlen > BZP_MAX_TREE_HEIGHT_ENCODE) {\n      for (int32_t i = 0; i < huffman->alphaSize; i++) {\n        int32_t w = (huffman->weight[i] >> BZP_HUFFMAN_HEIGHT_WEIGHT_BITS);\n        w = ((w >> 1) + 1);\n        huffman->weight[i] = w << BZP_HUFFMAN_HEIGHT_WEIGHT_BITS;\n      }\n    }\n  } while (maxlen > BZP_MAX_TREE_HEIGHT_ENCODE);\n}\n\nvoid BzpGetHuffmanTable(BzpHuffmanInfo *huffman) {\n  int32_t vec = 0;\n  int32_t mi = huffman->len[0], mx = huffman->len[0];\n  for (int32_t i = 0; i < huffman->alphaSize; i++) {\n    mi = BZP_MIN_FUN(mi, huffman->len[i]);\n    mx = BZP_MAX_FUN(mx, huffman->len[i]);\n  }\n  for (int32_t i = mi; i <= mx; i++) {\n    for (int32_t j = 0; j < huffman->alphaSize; j++) {\n      if (huffman->len[j] == i) {\n        huffman->table[j] = vec;\n        vec++;\n      }\n    }\n    vec <<= 1;\n  }\n}\n\nint32_t BzpHuffmanGroupsReset(BzpHuffmanGroups *huffman, int32_t alphaSize) {\n  if (BZP_INVALID_ALPHA_SIZE(alphaSize)) {\n    return BZP_ERROR_PARAM;\n  }\n\n  huffman->alphaSize = alphaSize;\n  huffman->block = NULL;\n  huffman->mtfFreq = NULL;\n  huffman->nSelect = 0;\n  huffman->nGroups = 0;\n\n  for (int32_t i = 0; i < BZP_MAX_GROUPS_NUM; i++) {\n    BzpHuffmanInit(alphaSize, &huffman->huffmanGroups[i]);\n  }\n  return BZP_OK;\n}\n\nBzpHuffmanGroups *BzpHuffmanGroupsInit(int32_t blockSize) {\n  if (BZP_INVALID_BLOCK_SIZE(blockSize)) {\n    return NULL;\n  }\n  BzpHuffmanGroups *huffmanGroups =\n      (BzpHuffmanGroups *)malloc(sizeof(BzpHuffmanGroups));\n  if (huffmanGroups == NULL) {\n    return NULL;\n  }\n  huffmanGroups->select = NULL;\n  huffmanGroups->selectMTF = NULL;\n  int32_t spaceSize =\n      blockSize * BZP_BASE_BLOCK_SIZE / BZP_ELEMS_NUM_IN_ONE_GROUP;\n  huffmanGroups->select = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n  huffmanGroups->selectMTF = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n  if (huffmanGroups->select == NULL || huffmanGroups->selectMTF == NULL) {\n    BzpBzpHuffmanGroupsFinish(huffmanGroups);\n    return NULL;\n  }\n  huffmanGroups->alphaSize = 0;\n  huffmanGroups->block = NULL;\n  huffmanGroups->mtfFreq = NULL;\n  huffmanGroups->nSelect = 0;\n  huffmanGroups->nGroups = 0;\n\n  for (int32_t i = 0; i < BZP_MAX_GROUPS_NUM; i++) {\n    BzpHuffmanInit(0, &huffmanGroups->huffmanGroups[i]);\n  }\n\n  return huffmanGroups;\n}\n\nvoid BzpBzpHuffmanGroupsFinish(BzpHuffmanGroups *huffman) {\n  if (huffman != NULL) {\n    if (huffman->select != NULL) {\n      free(huffman->select);\n      huffman->select = NULL;\n    }\n    if (huffman->selectMTF != NULL) {\n      free(huffman->selectMTF);\n      huffman->selectMTF = NULL;\n    }\n    free(huffman);\n    huffman = NULL;\n  }\n}\n\nint32_t BzpGetHuffmanGroups(int32_t nBlock) {\n  int32_t nGroups = 1;\n  if (nBlock < BZP_NGROUPS_BLOCK_NUM_LIMIT0) {\n    nGroups = BZP_NGROUPS_NUM_0;\n  } else if (nBlock < BZP_NGROUPS_BLOCK_NUM_LIMIT1) {\n    nGroups = BZP_NGROUPS_NUM_1;\n  } else if (nBlock < BZP_NGROUPS_BLOCK_NUM_LIMIT2) {\n    nGroups = BZP_NGROUPS_NUM_2;\n  } else if (nBlock < BZP_NGROUPS_BLOCK_NUM_LIMIT3) {\n    nGroups = BZP_NGROUPS_NUM_3;\n  } else {\n    nGroups = BZP_NGROUPS_NUM_4;\n  }\n  return nGroups;\n}\n\nvoid BzpGenerateSelectMTF(BzpHuffmanGroups *huffman) {\n  int32_t nGroups = huffman->nGroups;\n  int32_t list[nGroups];\n  for (int32_t i = 0; i < nGroups; i++) {\n    list[i] = i;\n  }\n  for (int32_t i = 0; i < huffman->nSelect; i++) {\n    int32_t pos = 0;\n    for (int32_t j = 0; j < nGroups; j++) {\n      if (huffman->select[i] == list[j]) {\n        pos = j;\n        break;\n      }\n    }\n    for (int32_t j = pos; j > 0; j--) {\n      list[j] = list[j - 1];\n    }\n    list[0] = huffman->select[i];\n    huffman->selectMTF[i] = pos;\n  }\n}\n\nvoid BzpInitLenArray(BzpHuffmanGroups *huffman) {\n  int32_t nGroups = huffman->nGroups;\n  int32_t npart = nGroups;\n  int32_t AllFreqNum = huffman->nBlock;\n  int32_t st = 0, ed;\n\n  while (npart > 0) {\n    int32_t NowFreqNum = 0;\n    int32_t FreqNumLimit = AllFreqNum / npart;\n\n    ed = st - 1;\n    while (ed < huffman->alphaSize - 1 && NowFreqNum < FreqNumLimit) {\n      ed++;\n      NowFreqNum += huffman->mtfFreq[ed];\n    }\n\n    if (ed > st && npart != nGroups && npart != 1 && ((nGroups - npart) & 1)) {\n      NowFreqNum -= huffman->mtfFreq[ed];\n      ed--;\n    }\n\n    for (int32_t i = 0; i < huffman->alphaSize; i++) {\n      if (i >= st && i <= ed) {\n        huffman->huffmanGroups[npart - 1].len[i] = 0;\n      } else {\n        huffman->huffmanGroups[npart - 1].len[i] = BZP_HUFFMAN_LEN_MAX_COST;\n      }\n    }\n    npart--;\n    st = ed + 1;\n    AllFreqNum -= NowFreqNum;\n  }\n}\n\nvoid BzpCalculateCost(BzpHuffmanGroups *huffman, int32_t st, int32_t ed) {\n  (void)memset_s(huffman->cost, sizeof(huffman->cost), 0,\n                 sizeof(huffman->cost));\n  int32_t nGroups = huffman->nGroups;\n  for (int32_t k = st; k <= ed; k++) {\n    for (int32_t t = 0; t < nGroups; t++) {\n      huffman->cost[t] += huffman->huffmanGroups[t].len[huffman->block[k]];\n    }\n  }\n}\nint32_t BzpSelectTree(BzpHuffmanGroups *huffman) {\n  int32_t id = 0;\n  int32_t nGroups = huffman->nGroups;\n  for (int32_t k = 0; k < nGroups; k++) {\n    if (huffman->cost[k] < huffman->cost[id]) {\n      id = k;\n    }\n  }\n  huffman->select[huffman->nSelect++] = id;\n  return id;\n}\n\nvoid BzpHuffmanMain(BzpHuffmanGroups *huffman) {\n  int32_t nGroups = BzpGetHuffmanGroups(huffman->nBlock);\n  huffman->nGroups = nGroups;\n\n  BzpInitLenArray(huffman);\n  int32_t st = 0, ed;\n\n  for (int32_t i = 0; i < BZP_MAX_ITER_NUM; i++) {\n    for (int32_t j = 0; j < nGroups; j++) {\n      (void)memset_s(huffman->huffmanGroups[j].weight,\n                     sizeof(huffman->huffmanGroups[j].weight), 0,\n                     sizeof(huffman->huffmanGroups[j].weight));\n    }\n\n    st = 0;\n    huffman->nSelect = 0;\n    while (st < huffman->nBlock) {\n      ed = BZP_MIN_FUN(huffman->nBlock,\n                       st + (int32_t)BZP_ELEMS_NUM_IN_ONE_GROUP) -\n           1;\n\n      BzpCalculateCost(huffman, st, ed);\n\n      int32_t id = BzpSelectTree(huffman);\n\n      for (int32_t k = st; k <= ed; k++) {\n        huffman->huffmanGroups[id].weight[huffman->block[k]]++;\n      }\n      st = ed + 1;\n    }\n\n    for (int32_t j = 0; j < nGroups; j++) {\n      BzpBuildTreeBalanceHeight(&huffman->huffmanGroups[j]);\n    }\n  }\n\n  BzpGenerateSelectMTF(huffman);\n\n  for (int32_t i = 0; i < nGroups; i++) {\n    BzpGetHuffmanTable(&huffman->huffmanGroups[i]);\n  }\n}\n\n#ifdef __cplusplus\n}\n#endif\n"
}