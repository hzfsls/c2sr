{"include/rapidlz.h": "# 1 \".tmp/include/rapidlz.h\"\n# 22 \".tmp/include/rapidlz.h\"\n#ifndef RAPIDLZ_H\n#define RAPIDLZ_H\n\n#include <stddef.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n# 55 \".tmp/include/rapidlz.h\"\nsize_t RapidlzCompressBound(size_t srcSize);\n# 88 \".tmp/include/rapidlz.h\"\nsize_t RapidlzCompress(const void *src, void *dst, size_t srcSize,\n                       size_t dstSize, int acceleration);\n# 119 \".tmp/include/rapidlz.h\"\nsize_t RapidlzDecompress(const void *src, void *dst, size_t srcSize,\n                         size_t dstSize);\n# 130 \".tmp/include/rapidlz.h\"\ntypedef void (*RapidlzLogFunc)(const char *message, size_t size);\n# 154 \".tmp/include/rapidlz.h\"\nvoid RapidlzLogRegister(RapidlzLogFunc func);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "src/rapidlz_log.c": "# 1 \".tmp/src/rapidlz_log.c\"\n# 9 \".tmp/src/rapidlz_log.c\"\n#include \"rapidlz_log.h\"\n#include \"securec.h\"\n#include <libgen.h>\n#include <stdarg.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define LOG_BUF_SIZE 1024\n\nstatic RapidlzLogFunc g_rapidlzLogFunc = NULL;\n\nvoid RapidlzLogWrite(size_t error_code, const char *file_name,\n                     unsigned short line, const char *fmt, ...) {\n  va_list alist;\n  char output[LOG_BUF_SIZE];\n  int ret, len;\n  RapidlzLogFunc func = g_rapidlzLogFunc;\n  char *filename;\n\n  if (func == NULL) {\n    return;\n  }\n\n  filename = strdup(file_name);\n  if (filename == NULL) {\n    return;\n  }\n\n  ret = snprintf_s(output, LOG_BUF_SIZE, LOG_BUF_SIZE - 1,\n                   \"\\n[Rapidlz-Log] File=%s, Line=%u, Error=%zu\\n\",\n                   basename(filename), line, error_code);\n  if (ret < 0) {\n    free(filename);\n    return;\n  }\n  len = ret;\n\n  free(filename);\n\n  va_start(alist, fmt);\n  ret = vsnprintf_s(output + len, LOG_BUF_SIZE - len, LOG_BUF_SIZE - len - 1,\n                    fmt, alist);\n  va_end(alist);\n  if (ret < 0) {\n    return;\n  }\n\n  func(output, strlen(output) + 1);\n}\n\nvoid RapidlzLogRegister(RapidlzLogFunc func) { g_rapidlzLogFunc = func; }\n\n#ifdef __cplusplus\n}\n#endif\n", "src/rapidlz_decompress.c": "# 1 \".tmp/src/rapidlz_decompress.c\"\n# 9 \".tmp/src/rapidlz_decompress.c\"\n#include \"rapidlz.h\"\n#include \"rapidlz_inner.h\"\n#include \"securec.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define SIXTEEN_BYTE 16\n#define EIGHT_BYTE 8\n#define COPY_PROTECT_SIZE 16\n#define MAX_4BIT_MATCH 19\n\nstatic uint8_t g_overlapOffAddVal[] = {0, 1, 2, 2, 4, 3, 2, 1};\n\n#define READ_OPTIONAL_LENGTH(len, srcCurr, srcEnd, temp)                       \\\n  do {                                                                         \\\n    if (LIKELY((srcCurr) < (srcEnd))) {                                        \\\n      (temp) = *(srcCurr)++;                                                   \\\n      (len) += (temp);                                                         \\\n    }                                                                          \\\n    while (((temp) == MAX_BYTE_VALUE) && (srcCurr) < (srcEnd)) {               \\\n      (temp) = *(srcCurr)++;                                                   \\\n      (len) += (temp);                                                         \\\n    }                                                                          \\\n  } while (0)\n\n#define SAFE_COPY_MATCH(dstCurr, matchSrc, matchLength)                        \\\n  do {                                                                         \\\n    while ((matchLength)-- > 0) {                                              \\\n      *(dstCurr)++ = *(matchSrc)++;                                            \\\n    }                                                                          \\\n  } while (0)\n\nstatic inline void RapidlzCopyLiteralsFast(const uint8_t *src, uint8_t *dst,\n                                           uint32_t length) {\n  if (LIKELY(length <= SIXTEEN_BYTE)) {\n    Copy16Byte(dst, src);\n    return;\n  }\n\n  RapidlzWildCopy16(src, dst, dst + length);\n}\n\nstatic inline void RapidlzCopyMatchFast(uint8_t *dst, uint8_t *match,\n                                        uint16_t offset, uint32_t length) {\n  uint8_t *dstCurr = dst;\n  uint8_t *matchPtr = match;\n\n  if (offset >= SIXTEEN_BYTE) {\n    RapidlzCopyLiteralsFast(matchPtr, dstCurr, length);\n    return;\n  }\n\n  for (int i = 0; i < EIGHT_BYTE; ++i) {\n    dstCurr[i] = matchPtr[i];\n  }\n\n  if (length <= EIGHT_BYTE) {\n    return;\n  }\n\n  uint8_t *dstEnd = dstCurr + length;\n  if (offset < EIGHT_BYTE) {\n    matchPtr += g_overlapOffAddVal[offset];\n    dstCurr += EIGHT_BYTE;\n  }\n\n  do {\n    Copy8Byte(dstCurr, matchPtr);\n    dstCurr += EIGHT_BYTE;\n    matchPtr += EIGHT_BYTE;\n  } while (dstCurr < dstEnd);\n}\n\nsize_t RapidlzDecompress(const void *src, void *dst, size_t srcSize,\n                         size_t dstSize) {\n  if (src == NULL || dst == NULL || srcSize == 0 || dstSize == 0) {\n    RAPIDLZ_LOG(RAPIDLZ_INPUT_INVALID, \"input invalid\\n\");\n    return 0;\n  }\n\n  uint8_t token, temp = 0;\n  register uint16_t offset;\n  register uint32_t litLen, matchLen;\n  uint8_t *matchSrc;\n  const uint8_t *srcEnd = (const uint8_t *)src + srcSize;\n  const uint8_t *srcCurr = (const uint8_t *)src;\n  const uint8_t *srcEndFast = srcEnd - COPY_PROTECT_SIZE;\n  uint8_t *dstEnd = (uint8_t *)dst + dstSize;\n  uint8_t *dstCurr = (uint8_t *)dst;\n  uint8_t *dstEndFast = dstEnd - COPY_PROTECT_SIZE;\n\n  while (srcCurr < srcEnd) {\n    token = *srcCurr++;\n    litLen = (token >> 4);\n\n    if (LIKELY(litLen < MAX_4BIT_VALUE)) {\n      if (LIKELY(srcCurr + litLen <= srcEndFast &&\n                 dstCurr + litLen <= dstEndFast)) {\n        Copy16Byte(dstCurr, srcCurr);\n        dstCurr += litLen;\n        srcCurr += litLen;\n        goto READ_MATCH;\n      }\n    } else {\n      READ_OPTIONAL_LENGTH(litLen, srcCurr, srcEnd, temp);\n      if (LIKELY(srcCurr + litLen <= srcEndFast &&\n                 dstCurr + litLen <= dstEndFast)) {\n        RapidlzWildCopy16(srcCurr, dstCurr, dstCurr + litLen);\n        dstCurr += litLen;\n        srcCurr += litLen;\n        goto READ_MATCH;\n      }\n    }\n\n    size_t leftSrcSize = srcEnd - srcCurr;\n    if (UNLIKELY(litLen > leftSrcSize || memmove_s(dstCurr, dstEnd - dstCurr,\n                                                   srcCurr, litLen) != EOK)) {\n      RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"litLen:%u dstEnd - dst:%zu\\n\",\n                  litLen, leftSrcSize);\n      return 0;\n    }\n\n    dstCurr += litLen;\n    srcCurr += litLen;\n\n    if (leftSrcSize == litLen) {\n      return dstCurr - (uint8_t *)(dst);\n    }\n\n  READ_MATCH:\n    offset = ReadLE16Bit(srcCurr);\n    srcCurr += 2;\n    matchSrc = dstCurr - offset;\n    if (UNLIKELY((void *)matchSrc < dst)) {\n      RAPIDLZ_LOG(RAPIDLZ_FORMAT_INVALID, \"rapidlz format invalid\\n\");\n      return 0;\n    }\n\n    matchLen = (token & MAX_4BIT_VALUE) + MIN_MATCH;\n    if (matchLen == MAX_4BIT_MATCH) {\n      READ_OPTIONAL_LENGTH(matchLen, srcCurr, srcEnd, temp);\n    }\n\n    if (LIKELY(dstCurr + matchLen <= dstEndFast)) {\n      RapidlzCopyMatchFast(dstCurr, matchSrc, offset, matchLen);\n      dstCurr += matchLen;\n    } else {\n      if (dstCurr + matchLen > dstEnd) {\n        RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL,\n                    \"dstEnd - dstCurr:%zu matchLen:%u\\n\", dstEnd - dstCurr,\n                    matchLen);\n        return 0;\n      }\n\n      SAFE_COPY_MATCH(dstCurr, matchSrc, matchLen);\n    }\n  }\n\n  return dstCurr - (uint8_t *)dst;\n}\n\n#ifdef __cplusplus\n}\n#endif\n", "src/rapidlz_log.h": "# 1 \".tmp/src/rapidlz_log.h\"\n# 18 \".tmp/src/rapidlz_log.h\"\n#ifndef RAPIDLZ_LOG_H\n#define RAPIDLZ_LOG_H\n\n#include \"rapidlz.h\"\n#include <stdio.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef RAPIDLZFILENAME\n#ifdef RAPIDLZ_FILE_NAME\n#define RAPIDLZFILENAME \"\"\n#else\n#define RAPIDLZFILENAME                                                        \\\n  (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)\n#endif\n#endif\n# 43 \".tmp/src/rapidlz_log.h\"\n#define RAPIDLZ_LOG(error_code, fmt, ...)                                      \\\n  do {                                                                         \\\n    RapidlzLogWrite((size_t)(error_code), RAPIDLZFILENAME, __LINE__, fmt,      \\\n                    __VA_ARGS__);                                              \\\n  } while (0)\n# 60 \".tmp/src/rapidlz_log.h\"\nvoid RapidlzLogWrite(size_t error_code, const char *file_name,\n                     unsigned short line, const char *fmt, ...)\n    __attribute__((format(printf, (4), (5))));\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n", "src/rapidlz_inner.h": "# 1 \".tmp/src/rapidlz_inner.h\"\n# 9 \".tmp/src/rapidlz_inner.h\"\n#ifndef RAPIDLZ_INNER_H\n#define RAPIDLZ_INNER_H\n\n#include \"rapidlz_log.h\"\n#include <assert.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#if defined(__SSE2__) || defined(_M_AMD64)\n#define X86_SSE2\n#endif\n\n#if defined(__ARM_NEON) || defined(_M_ARM64)\n#define ARM_NEON\n#endif\n\n#if defined(X86_SSE2)\n#include <emmintrin.h>\n#endif\n\n#if defined(ARM_NEON)\n#include <arm_neon.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define MAX_BYTE_VALUE 255\n#define MAX_4BIT_VALUE 15\n#define MIN_MATCH 4\n# 48 \".tmp/src/rapidlz_inner.h\"\n#define RAPIDLZ_INPUT_INVALID (size_t)(-100)\n\n#define RAPIDLZ_MALLOC_FAILED (size_t)(-99)\n\n#define RAPIDLZ_DST_SIZE_SMALL (size_t)(-98)\n\n#define RAPIDLZ_SECUREC_ERROR (size_t)(-97)\n\n#define RAPIDLZ_FORMAT_INVALID (size_t)(-96)\n\n#if defined(__GNUC__) && (__GNUC__ >= 4)\n#define RAPIDLZ_ALWAYS_INLINE inline __attribute__((always_inline))\n#else\n#define RAPIDLZ_ALWAYS_INLINE inline\n#endif\n\n#define LIKELY(x) (__builtin_expect(!!(x), 1))\n\n#define UNLIKELY(x) (__builtin_expect(!!(x), 0))\n\n#if defined(_MSC_VER) || (defined(__INTEL_COMPILER) && defined(WIN32))\ntypedef struct {\n  uint16_t v;\n} UnalignU16;\ntypedef struct {\n  uint32_t v;\n} UnalignU32;\ntypedef struct {\n  uint64_t v;\n} UnalignU64;\ntypedef struct {\n  int64_t v;\n} Unalign64;\n#else\ntypedef struct {\n  uint16_t v;\n} __attribute__((packed)) UnalignU16;\ntypedef struct {\n  uint32_t v;\n} __attribute__((packed)) UnalignU32;\ntypedef struct {\n  uint64_t v;\n} __attribute__((packed)) UnalignU64;\n#endif\n\n#define READ16BIT(ptr) (((const UnalignU16 *)(ptr))->v)\n#define READ32BIT(ptr) (((const UnalignU32 *)(ptr))->v)\n#define READ64BIT(ptr) (((const UnalignU64 *)(ptr))->v)\n#define WRITE64BIT(ptr, val) (((UnalignU64 *)(ptr))->v = (val))\n\n#define RAPIDLZ_ASSERT(x) assert(x)\n\nstatic inline int IsLE(void) {\n#if (defined(__GNUC__) || defined(__clang__))\n  return __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__;\n#endif\n  int n = 1;\n  return *(char *)(&n);\n}\n\nstatic inline uint16_t ReadLE16Bit(const void *addr) {\n  if (IsLE() != 0) {\n    return *(const uint16_t *)addr;\n  }\n\n  uint8_t tmp1 = ((const uint8_t *)addr)[0];\n  uint8_t tmp2 = ((const uint8_t *)addr)[1];\n  return (uint16_t)(tmp1 + (tmp2 << 8));\n}\n\nstatic inline uint8_t CountTailZero64(uint64_t x) {\n#if (defined(__GNUC__) && (__GNUC__ >= 3))\n  return (uint8_t)__builtin_ctzll(x);\n#endif\n  if (x == 0) {\n    return 0;\n  }\n  uint64_t val = x;\n  uint8_t num = 0;\n  while ((val & 1) == 0) {\n    val >>= 1;\n    num++;\n  }\n  return num;\n}\n\nstatic inline uint8_t CountLeadZero64(uint64_t x) {\n#if (defined(__GNUC__) && (__GNUC__ >= 3))\n  return (uint8_t)__builtin_clzll(x);\n#endif\n  if (x == 0) {\n    return 0;\n  }\n  uint8_t num = 0;\n  uint64_t val = x;\n  while ((val & 0x8000000000000000ULL) == 0) {\n    val <<= 1;\n    num++;\n  }\n  return num;\n}\n\nstatic inline uint8_t HighBit64(uint64_t x) {\n  RAPIDLZ_ASSERT(x != 0);\n\n#if (defined(__GNUC__) && (__GNUC__ >= 3))\n  return ((uint8_t)__builtin_clzll(x) ^ 63);\n#endif\n  uint8_t pos = 64;\n  uint64_t val = x;\n\n  if (val == 0) {\n    return 0;\n  }\n  if ((val & 0xFFFFFFFF00000000) == 0) {\n    val <<= 32;\n    pos -= 32;\n  }\n  if ((val & 0xFFFF000000000000) == 0) {\n    val <<= 16;\n    pos -= 16;\n  }\n  if ((val & 0xFF00000000000000) == 0) {\n    val <<= 8;\n    pos -= 8;\n  }\n  if ((val & 0xF000000000000000) == 0) {\n    val <<= 4;\n    pos -= 4;\n  }\n  if ((val & 0xC000000000000000) == 0) {\n    val <<= 2;\n    pos -= 2;\n  }\n  if ((val & 0x8000000000000000) == 0) {\n    val <<= 1;\n    pos -= 1;\n  }\n\n  return pos - 1;\n}\n# 252 \".tmp/src/rapidlz_inner.h\"\nstatic inline void WriteLE16(void *addr, uint16_t val) {\n  if (IsLE() != 0) {\n    *(uint16_t *)addr = val;\n  } else {\n    uint8_t *tmp = (uint8_t *)addr;\n    tmp[0] = (uint8_t)val;\n    tmp[1] = (uint8_t)(val >> 8);\n  }\n}\n# 271 \".tmp/src/rapidlz_inner.h\"\nstatic inline void Copy32Byte(void *dst, const void *src) {\n#if defined(ARM_NEON)\n\n  vst1q_u8((uint8_t *)dst, vld1q_u8((const uint8_t *)src));\n  vst1q_u8((uint8_t *)dst + 16, vld1q_u8((const uint8_t *)src + 16));\n#elif defined(X86_SSE2)\n  _mm_storeu_si128((__m128i *)dst, _mm_loadu_si128((const __m128i *)src));\n  _mm_storeu_si128((__m128i *)dst + 1,\n                   _mm_loadu_si128((const __m128i *)src + 1));\n#else\n  WRITE64BIT(dst, READ64BIT(src));\n  WRITE64BIT((uint8_t *)dst + 8, READ64BIT((uint8_t *)src + 8));\n  WRITE64BIT((uint8_t *)dst + 16, READ64BIT((uint8_t *)src + 16));\n  WRITE64BIT((uint8_t *)dst + 24, READ64BIT((uint8_t *)src + 24));\n#endif\n}\n# 296 \".tmp/src/rapidlz_inner.h\"\nstatic inline void Copy16Byte(void *dst, const void *src) {\n#if defined(ARM_NEON)\n  vst1q_u8((uint8_t *)dst, vld1q_u8((const uint8_t *)src));\n#elif defined(X86_SSE2)\n  _mm_storeu_si128((__m128i *)dst, _mm_loadu_si128((const __m128i *)src));\n#else\n  WRITE64BIT(dst, READ64BIT(src));\n  WRITE64BIT((uint8_t *)dst + 8, READ64BIT((uint8_t *)src + 8));\n#endif\n}\n# 316 \".tmp/src/rapidlz_inner.h\"\nstatic inline void Copy8Byte(void *dst, const void *src) {\n#if defined(ARM_NEON)\n  vst1_u8((uint8_t *)dst, vld1_u8((const uint8_t *)src));\n#elif defined(X86_SSE2)\n  _mm_storel_epi64((__m128i *)dst, _mm_loadu_si128((const __m128i *)src));\n#else\n  WRITE64BIT(dst, READ64BIT(src));\n#endif\n}\n\nstatic inline void RapidlzWildCopy8(const uint8_t *srcPtr, uint8_t *dstPtr,\n                                    uint8_t *dstEnd) {\n  uint8_t *tmpDstPtr = dstPtr;\n  const uint8_t *tmpSrcPtr = srcPtr;\n  do {\n    Copy8Byte(tmpDstPtr, tmpSrcPtr);\n    tmpDstPtr += 8;\n    tmpSrcPtr += 8;\n  } while (tmpDstPtr < dstEnd);\n}\n\nstatic inline void RapidlzWildCopy16(const uint8_t *srcPtr, uint8_t *dstPtr,\n                                     uint8_t *dstEnd) {\n  uint8_t *tmpDstPtr = dstPtr;\n  const uint8_t *tmpSrcPtr = srcPtr;\n  do {\n    Copy16Byte(tmpDstPtr, tmpSrcPtr);\n    tmpDstPtr += 16;\n    tmpSrcPtr += 16;\n  } while (tmpDstPtr < dstEnd);\n}\n\nstatic inline void RapidlzWildCopy32(const uint8_t *srcPtr, uint8_t *dstPtr,\n                                     uint8_t *dstEnd) {\n  uint8_t *tmpDstPtr = dstPtr;\n  const uint8_t *tmpSrcPtr = srcPtr;\n  do {\n    Copy32Byte(tmpDstPtr, tmpSrcPtr);\n    tmpDstPtr += 32;\n    tmpSrcPtr += 32;\n  } while (tmpDstPtr < dstEnd);\n}\n# 371 \".tmp/src/rapidlz_inner.h\"\nsize_t RapidlzCompressDefault(const void *src, void *dst, size_t srcSize,\n                              size_t dstSize);\n# 381 \".tmp/src/rapidlz_inner.h\"\nconst char *RapidlzVersionGet(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "src/rapidlz_compress.c": "# 1 \".tmp/src/rapidlz_compress.c\"\n# 9 \".tmp/src/rapidlz_compress.c\"\n#include \"rapidlz.h\"\n#include \"rapidlz_inner.h\"\n#include \"securec.h\"\n#include <stddef.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define MAX_INPUT_SIZE 0x7E000000U\n#define RAPIDLZ_COMPRESSBOUND(size)                                            \\\n  ((size) > MAX_INPUT_SIZE ? 0 : (size) + ((size) / 255) + 16)\n\n#define RAPIDLZ_ACCELERATION_MAX 10\n#define SRC_SIZE_THRESHOLD 65536\n#define MAX_OFFSET 65535\n#define LAST_LITERALS 6\n#define MIN_COMPRESS_SIZE 16\n#define HASH_TYPE_4 4\n#define HASH_TYPE_5 5\n#define MIN_HASH_BIT 6\n#define MAX_HASH_BIT 12\n#define STEP_FORWARD_BASE 6\n\n#define EXPAND_FORWARD(srcBegin, matchBegin, srcCurr, srcAnchor)               \\\n  do {                                                                         \\\n    while ((srcBegin) < (matchBegin) && (srcCurr) > (srcAnchor) &&             \\\n           UNLIKELY((matchBegin)[-1] == (srcCurr)[-1])) {                      \\\n      (matchBegin)--;                                                          \\\n      (srcCurr)--;                                                             \\\n    }                                                                          \\\n  } while (0)\n\ntypedef struct {\n  uint8_t *hashTable;\n  uint8_t hashType;\n  uint8_t hashBits;\n  uint8_t step;\n  uint8_t bufferLimit;\n} RapidlzCCtx;\n\nstatic const char *g_rapidlzVersion = \"rapidlz 3.24.00.SPC010B100\";\n\nconst char *RapidlzVersionGet(void) { return g_rapidlzVersion; }\n\nsize_t RapidlzCompressBound(size_t srcSize) {\n\n  return RAPIDLZ_COMPRESSBOUND(srcSize);\n}\n\nstatic inline void PutPosOnTable(uint32_t pos, uint32_t hashValue,\n                                 uint8_t *hashTable, uint8_t hashType) {\n  if (hashType == 4) {\n    *(((uint16_t *)hashTable) + hashValue) = (uint16_t)pos;\n  } else if (hashType == 5) {\n    *(((uint32_t *)hashTable) + hashValue) = (uint32_t)pos;\n  }\n}\n\nstatic inline uint32_t GetPosOnTable(uint32_t hashValue, uint8_t *hashTable,\n                                     uint8_t hashType) {\n  if (hashType == 4) {\n    return (uint32_t)(*(((uint16_t *)hashTable) + hashValue));\n  } else if (hashType == 5) {\n    return (*(((uint32_t *)hashTable) + hashValue));\n  }\n\n  return 0;\n}\n\nstatic inline uint32_t CalcHashValue(const uint8_t *srcCurr, uint8_t hashType,\n                                     uint8_t hashBits) {\n  if (hashType == 5) {\n    return (\n        uint32_t)((((READ64BIT(srcCurr)) << 24) * 11400714819323198485ULL) >>\n                  (64 - hashBits));\n  } else {\n    return (READ32BIT(srcCurr) * 2654435769U) >> (32 - hashBits);\n  }\n}\n\nstatic inline const uint8_t *\nRapidlzCompressExpandBackward(const uint8_t *matchLimit,\n                              const uint8_t *matchPtr, const uint8_t *srcCurr) {\n  uint64_t xorVal;\n  const uint8_t *loopEnd = matchLimit - 7;\n  const uint8_t *srcCurrMatchEnd = srcCurr;\n  const uint8_t *matchBegin = matchPtr;\n\n  while (srcCurrMatchEnd < loopEnd) {\n    xorVal = READ64BIT(matchBegin) ^ READ64BIT(srcCurrMatchEnd);\n    if (UNLIKELY(xorVal == 0)) {\n      srcCurrMatchEnd += sizeof(uint64_t);\n      matchBegin += sizeof(uint64_t);\n      continue;\n    }\n    srcCurrMatchEnd += IsLE() ? (CountTailZero64(xorVal) >> 3)\n                              : (CountLeadZero64(xorVal) >> 3);\n    return srcCurrMatchEnd;\n  }\n\n  if (((srcCurrMatchEnd + 3) < matchLimit) &&\n      (READ32BIT(srcCurrMatchEnd) == READ32BIT(matchBegin))) {\n    srcCurrMatchEnd += sizeof(uint32_t);\n    matchBegin += sizeof(uint32_t);\n  }\n\n  if (((srcCurrMatchEnd + 1) < matchLimit) &&\n      (READ16BIT(srcCurrMatchEnd) == READ16BIT(matchBegin))) {\n    srcCurrMatchEnd += sizeof(uint16_t);\n    matchBegin += sizeof(uint16_t);\n  }\n\n  if ((srcCurrMatchEnd < matchLimit) && (srcCurrMatchEnd[0] == matchBegin[0])) {\n    srcCurrMatchEnd++;\n  }\n  return srcCurrMatchEnd;\n}\n\nstatic inline uint8_t *RapidlzCompressStoreOptionalLength(uint8_t *dst,\n                                                          uint32_t litLength) {\n  uint8_t *dstCurr = dst;\n  uint32_t length = litLength;\n\n  if (length < MAX_BYTE_VALUE) {\n    *dstCurr = (uint8_t)length;\n    dstCurr++;\n    return dstCurr;\n  }\n\n  do {\n    *dstCurr = MAX_BYTE_VALUE;\n    dstCurr++;\n    length -= MAX_BYTE_VALUE;\n  } while (length >= MAX_BYTE_VALUE);\n\n  *dstCurr = (uint8_t)length;\n  dstCurr++;\n  return dstCurr;\n}\n\nstatic inline uint8_t *RapidlzStoreLastLiterals(uint8_t *dst, uint8_t *dstEnd,\n                                                const uint8_t *srcCurr,\n                                                uint32_t litLength,\n                                                uint8_t bufferLimit) {\n  uint8_t *dstCurr = dst;\n\n  if (bufferLimit != 0) {\n    const uint32_t litTokSize = 1 + litLength + (litLength / MAX_BYTE_VALUE);\n    if (dstCurr + litTokSize > dstEnd) {\n      RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"dstEnd - dstCur:%zu litTokSize:%u\\n\",\n                  dstEnd - dstCurr, litTokSize);\n      return NULL;\n    }\n  }\n\n  uint8_t token =\n      (uint8_t)(((litLength < MAX_4BIT_VALUE) ? (litLength) : (MAX_4BIT_VALUE))\n                << 4);\n  *dstCurr = token;\n  dstCurr++;\n\n  if (litLength >= MAX_4BIT_VALUE) {\n    dstCurr =\n        RapidlzCompressStoreOptionalLength(dstCurr, litLength - MAX_4BIT_VALUE);\n  }\n\n  if (memcpy_s(dstCurr, dstEnd - dstCurr, srcCurr, litLength) != EOK) {\n    RAPIDLZ_LOG(RAPIDLZ_SECUREC_ERROR, \"dstEnd - dstCurr:%zu litLength%u\\n\",\n                dstEnd - dstCurr, litLength);\n    return NULL;\n  }\n\n  return dstCurr + litLength;\n}\n\nstatic inline uint8_t *RapidlzStoreOffMatch(uint8_t *dst, uint8_t *token,\n                                            uint32_t matchLength,\n                                            uint16_t offset) {\n  uint8_t *dstCurr = dst;\n\n  WriteLE16(dstCurr, offset);\n  dstCurr += 2;\n\n  if (matchLength >= MAX_4BIT_VALUE) {\n    uint32_t optionalLen = matchLength - MAX_4BIT_VALUE;\n    *token += MAX_4BIT_VALUE;\n    for (; optionalLen >= MAX_BYTE_VALUE; optionalLen -= MAX_BYTE_VALUE) {\n      *dstCurr++ = MAX_BYTE_VALUE;\n    }\n    *dstCurr++ = (uint8_t)optionalLen;\n  } else {\n    *token += (uint8_t)matchLength;\n  }\n\n  return dstCurr;\n}\n\nstatic inline uint8_t *RapidlzStoreSequence(uint8_t *dst,\n                                            const uint8_t *srcAnchor,\n                                            uint32_t literalLength,\n                                            uint32_t matchLength,\n                                            uint16_t offset) {\n  uint8_t *dstCurr = dst;\n  uint8_t *token = dstCurr++;\n\n  if (literalLength >= MAX_4BIT_VALUE) {\n    *token = (MAX_4BIT_VALUE << 4);\n    uint32_t optionalLen = literalLength - MAX_4BIT_VALUE;\n    for (; optionalLen >= MAX_BYTE_VALUE; optionalLen -= MAX_BYTE_VALUE) {\n      *dstCurr++ = (uint8_t)MAX_BYTE_VALUE;\n    }\n    *dstCurr++ = (uint8_t)optionalLen;\n    Copy16Byte(dstCurr, srcAnchor);\n    if (literalLength > 16) {\n      RapidlzWildCopy16(srcAnchor + 16, dstCurr + 16, dstCurr + literalLength);\n    }\n    dstCurr += literalLength;\n  } else if (literalLength > 0) {\n    *token = (uint8_t)(literalLength << 4);\n    Copy16Byte(dstCurr, srcAnchor);\n    dstCurr += literalLength;\n  } else {\n    *token = 0;\n  }\n\n  return RapidlzStoreOffMatch(dstCurr, token, matchLength, offset);\n}\n\nstatic size_t RapidlzCompressProcess(void *dst, size_t dstSize, const void *src,\n                                     size_t srcSize, RapidlzCCtx *cCtx) {\n  uint32_t hashValue, matchLength, literalLength;\n  uint32_t step = 1;\n  uint16_t offset;\n  uint8_t *hashTable = cCtx->hashTable;\n  const uint8_t *srcBegin = (const uint8_t *)src;\n  const uint8_t *srcEnd = (const uint8_t *)src + srcSize;\n  const uint8_t *srcCurr = srcBegin + 1;\n  const uint8_t *srcCurrMatchEnd;\n  const uint8_t *srcAnchor = srcBegin;\n  const uint8_t *matchBegin;\n  const uint8_t *matchLimit = srcEnd - LAST_LITERALS;\n  const uint8_t *srcLimit = srcEnd - MIN_COMPRESS_SIZE;\n  uint8_t *dstBegin = (uint8_t *)dst;\n  uint8_t *dstEnd = (uint8_t *)dst + dstSize;\n  uint8_t *dstCurr = dstBegin;\n  uint8_t hashType = cCtx->hashType;\n  uint8_t hashBits = cCtx->hashBits;\n  uint32_t searchMatchNb = cCtx->step << STEP_FORWARD_BASE;\n  uint32_t searchMatchNbTmp = searchMatchNb;\n  uint8_t bufferLimit = cCtx->bufferLimit;\n\n  while (LIKELY(srcCurr <= srcLimit)) {\n    for (;;) {\n      hashValue = CalcHashValue(srcCurr, hashType, hashBits);\n      matchBegin = srcBegin + GetPosOnTable(hashValue, hashTable, hashType);\n      PutPosOnTable(srcCurr - srcBegin, hashValue, hashTable, hashType);\n\n      if ((READ32BIT(srcCurr) == READ32BIT(matchBegin)) &&\n          LIKELY((srcCurr - matchBegin) <= MAX_OFFSET)) {\n        break;\n      }\n\n      srcCurr += step;\n      step = (searchMatchNbTmp++ >> STEP_FORWARD_BASE);\n\n      if (srcCurr > srcLimit) {\n        dstCurr = RapidlzStoreLastLiterals(dstCurr, dstEnd, srcAnchor,\n                                           srcEnd - srcAnchor, bufferLimit);\n        if (dstCurr == NULL) {\n          return 0;\n        }\n        return dstCurr - dstBegin;\n      }\n    }\n    step = 1;\n    searchMatchNbTmp = searchMatchNb;\n\n    srcCurrMatchEnd = RapidlzCompressExpandBackward(\n        matchLimit, matchBegin + MIN_MATCH, srcCurr + MIN_MATCH);\n    EXPAND_FORWARD(srcBegin, matchBegin, srcCurr, srcAnchor);\n    matchLength = srcCurrMatchEnd - srcCurr - MIN_MATCH;\n    offset = (uint16_t)(srcCurr - matchBegin);\n    literalLength = srcCurr - srcAnchor;\n    if (bufferLimit != 0) {\n      uint32_t writeSize =\n          literalLength + 8 + (literalLength + matchLength / MAX_BYTE_VALUE);\n      if (UNLIKELY(dstCurr + writeSize > dstEnd)) {\n        RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL,\n                    \"dstEnd - dstCur:%zu writeSize:%u\\n\", dstEnd - dstCurr,\n                    writeSize);\n        return 0;\n      }\n    }\n    dstCurr = RapidlzStoreSequence(dstCurr, srcAnchor, literalLength,\n                                   matchLength, offset);\n    srcCurr = srcCurrMatchEnd;\n    srcAnchor = srcCurr;\n    hashValue = CalcHashValue(srcCurr - 2, hashType, hashBits);\n    PutPosOnTable(srcCurr - 2 - srcBegin, hashValue, hashTable, hashType);\n\n    if (UNLIKELY(srcCurr > srcLimit)) {\n      break;\n    }\n\n    hashValue = CalcHashValue(srcCurr, hashType, hashBits);\n    matchBegin = srcBegin + GetPosOnTable(hashValue, hashTable, hashType);\n    PutPosOnTable(srcCurr - srcBegin, hashValue, hashTable, hashType);\n\n    if ((READ32BIT(srcCurr) != READ32BIT(matchBegin)) ||\n        UNLIKELY((srcCurr - matchBegin) > MAX_OFFSET)) {\n      srcCurr++;\n      continue;\n    }\n\n    srcCurrMatchEnd = RapidlzCompressExpandBackward(\n        matchLimit, matchBegin + MIN_MATCH, srcCurr + MIN_MATCH);\n    matchLength = srcCurrMatchEnd - srcCurr - MIN_MATCH;\n    offset = (uint16_t)(srcCurr - matchBegin);\n    if (bufferLimit != 0) {\n      const uint32_t writeSize = 8 + matchLength / MAX_BYTE_VALUE;\n      if (UNLIKELY(dstCurr + writeSize > dstEnd)) {\n        RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL,\n                    \"dstEnd - dstCur:%zu writeSize:%u\\n\", dstEnd - dstCurr,\n                    writeSize);\n        return 0;\n      }\n    }\n    *dstCurr = 0;\n    dstCurr = RapidlzStoreOffMatch(dstCurr + 1, dstCurr, matchLength, offset);\n\n    srcCurr = srcCurrMatchEnd;\n    srcAnchor = srcCurr;\n\n    hashValue = CalcHashValue(srcCurr - 2, hashType, hashBits);\n    PutPosOnTable(srcCurr - 2 - srcBegin, hashValue, hashTable, hashType);\n  }\n\n  if (srcAnchor < srcEnd) {\n    dstCurr = RapidlzStoreLastLiterals(dstCurr, dstEnd, srcAnchor,\n                                       srcEnd - srcAnchor, bufferLimit);\n    if (dstCurr == NULL) {\n      return 0;\n    }\n  }\n\n  return dstCurr - dstBegin;\n}\n\nstatic void RapidlzCCtxFree(RapidlzCCtx *cCtx) {\n  if (cCtx != NULL) {\n    if (cCtx->hashTable != NULL) {\n      free(cCtx->hashTable);\n      cCtx->hashTable = NULL;\n    }\n\n    free(cCtx);\n  }\n}\n\nsize_t RapidlzCompress(const void *src, void *dst, size_t srcSize,\n                       size_t dstSize, int acceleration) {\n  if (src == NULL || dst == NULL || srcSize == 0 || dstSize == 0) {\n    RAPIDLZ_LOG(RAPIDLZ_INPUT_INVALID, \"input invalid\\n\");\n    return 0;\n  }\n\n  if (acceleration < 1 || acceleration > RAPIDLZ_ACCELERATION_MAX) {\n    RAPIDLZ_LOG(RAPIDLZ_INPUT_INVALID, \"acceleration:%d\\n\", acceleration);\n    return 0;\n  }\n\n  RapidlzCCtx *cCtx = (RapidlzCCtx *)malloc(sizeof(RapidlzCCtx));\n  if (cCtx == NULL) {\n    RAPIDLZ_LOG(RAPIDLZ_MALLOC_FAILED, \"cCtx malloc failed\\n\");\n    return 0;\n  }\n\n  cCtx->hashBits = MIN_HASH_BIT;\n  size_t totalHashSize;\n  if (srcSize <= SRC_SIZE_THRESHOLD) {\n    cCtx->hashType = HASH_TYPE_4;\n    if (srcSize >= 64) {\n      cCtx->hashBits = (HighBit64(srcSize) > MAX_HASH_BIT) ? (MAX_HASH_BIT + 1)\n                                                           : HighBit64(srcSize);\n    }\n    totalHashSize = sizeof(uint16_t) * (uint32_t)(1 << cCtx->hashBits);\n  } else {\n    cCtx->hashType = HASH_TYPE_5;\n    cCtx->hashBits = MAX_HASH_BIT;\n    totalHashSize = sizeof(uint32_t) * (uint32_t)(1 << cCtx->hashBits);\n  }\n\n  uint8_t *table = (uint8_t *)malloc(totalHashSize);\n  if (table == NULL) {\n    RAPIDLZ_LOG(RAPIDLZ_MALLOC_FAILED, \"hash table malloc failed\\n\");\n    free(cCtx);\n    return 0;\n  }\n  (void)memset_s(table, totalHashSize, 0, totalHashSize);\n  cCtx->hashTable = table;\n  cCtx->step = (uint8_t)acceleration;\n  cCtx->bufferLimit = dstSize < RapidlzCompressBound(srcSize);\n\n  size_t cSize = RapidlzCompressProcess(dst, dstSize, src, srcSize, cCtx);\n  RapidlzCCtxFree(cCtx);\n  return cSize;\n}\n\nsize_t RapidlzCompressDefault(const void *src, void *dst, size_t srcSize,\n                              size_t dstSize) {\n  return RapidlzCompress(src, dst, srcSize, dstSize, 1);\n}\n\n#ifdef __cplusplus\n}\n#endif\n"}