{"include/sha256.h": "# 1 \".tmp/include/sha256.h\"\n# 25 \".tmp/include/sha256.h\"\n#ifndef SHA256_H\n#define SHA256_H\n\n#include <stddef.h>\n#include <stdint.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define VOS_SHA256_CTX_HASH_LEN 8\n\n#define VOS_SHA256_CTX_BUF_LEN 16\n\n#define SHA256_BLOCK_SIZE 64\n\n#define SHA256_DIGEST_SIZE 32\n\ntypedef struct {\n  uint32_t h[8];\n  uint32_t N[2];\n  uint32_t block[SHA256_BLOCK_SIZE / sizeof(uint32_t)];\n  uint32_t blocklen;\n  uint32_t outlen;\n  uint32_t computed : 1;\n  uint32_t corrupted : 1;\n} VOS_SHA256_CTX;\n# 86 \".tmp/include/sha256.h\"\nvoid vosSha256Begin(VOS_SHA256_CTX *pstCtx);\n# 104 \".tmp/include/sha256.h\"\nvoid vosSha256Hash(const uint8_t *pucData, uint32_t uiLen,\n                   VOS_SHA256_CTX *pstCtx);\n# 122 \".tmp/include/sha256.h\"\nvoid vosSha256End(uint8_t *pucOut, uint32_t uiOutSize, VOS_SHA256_CTX *pstCtx);\n# 141 \".tmp/include/sha256.h\"\nvoid VOS_Sha256Calc(const uint8_t *pucInput, uint32_t uiInputLen,\n                    uint8_t *pucOutput, uint32_t uiOutputLen);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "src/sha256.c": "# 1 \".tmp/src/sha256.c\"\n# 21 \".tmp/src/sha256.c\"\n#include \"sha256.h\"\n#include \"securec.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define SHA256_OK 0\n\n#define SHA256_ERROR ((uint32_t)(~0))\n\n#define BITS_PRE_BYTE 8\n#define SHIFTS_PER_BYTE 3\n#define BITSIZE(t) (sizeof(t) * BITS_PRE_BYTE)\n\n#ifndef PUT_UINT32_BE\n#define PUT_UINT32_BE(v, p, i)\ndo {\n  (p)[(i) + 0] = (uint8_t)((v) >> 24);\n  (p)[(i) + 1] = (uint8_t)((v) >> 16);\n  (p)[(i) + 2] = (uint8_t)((v) >> 8);\n  (p)[(i) + 3] = (uint8_t)((v) >> 0);\n} while (0)\n#endif\n\n#ifndef GET_UINT32_BE\n#define GET_UINT32_BE(p, i)                                                    \\\n  (((uint32_t)(p)[(i) + 0] << 24) | ((uint32_t)(p)[(i) + 1] << 16) |           \\\n   ((uint32_t)(p)[(i) + 2] << 8) | ((uint32_t)(p)[(i) + 3] << 0))\n#endif\n\n    static void\n    vosSha256CompressMul(VOS_SHA256_CTX *pstCtx, const uint8_t *pucInput,\n                         uint32_t uiNum);\n\nvoid vosSha256Begin(VOS_SHA256_CTX *pstCtx) {\n  if (pstCtx == NULL) {\n    return;\n  }\n\n  (void)memset_s(pstCtx, sizeof(VOS_SHA256_CTX), 0, sizeof(VOS_SHA256_CTX));\n  pstCtx->h[0] = 0x6a09e667UL;\n  pstCtx->h[1] = 0xbb67ae85UL;\n  pstCtx->h[2] = 0x3c6ef372UL;\n  pstCtx->h[3] = 0xa54ff53aUL;\n  pstCtx->h[4] = 0x510e527fUL;\n  pstCtx->h[5] = 0x9b05688cUL;\n  pstCtx->h[6] = 0x1f83d9abUL;\n  pstCtx->h[7] = 0x5be0cd19UL;\n  pstCtx->outlen = SHA256_DIGEST_SIZE;\n}\n\nstatic uint32_t vosSha256CtxPrepare(VOS_SHA256_CTX *pstCtx, uint32_t uiLen) {\n  uint32_t uiCntFirst;\n  uint32_t uiCntSec;\n\n  uiCntFirst = (pstCtx->N[0] + (uiLen << SHIFTS_PER_BYTE)) & 0xffffffffUL;\n  if (uiCntFirst < pstCtx->N[0]) {\n    ++pstCtx->N[1];\n    if (pstCtx->N[1] == 0) {\n      pstCtx->corrupted = 1;\n      return SHA256_ERROR;\n    }\n  }\n\n  uiCntSec = pstCtx->N[1] + (uiLen >> (BITSIZE(uint32_t) - SHIFTS_PER_BYTE));\n  if (uiCntSec < pstCtx->N[1]) {\n    pstCtx->corrupted = 1;\n    return SHA256_ERROR;\n  }\n\n  pstCtx->N[1] = uiCntSec;\n  pstCtx->N[0] = uiCntFirst;\n  return SHA256_OK;\n}\n\nstatic uint32_t vosSha256LastPadding(const uint8_t *pucData, uint32_t uiLen,\n                                     VOS_SHA256_CTX *pstCtx,\n                                     uint32_t *puiPaddingLen) {\n  errno_t err;\n  uint32_t uiBlcLen = pstCtx->blocklen;\n  uint8_t *pucBlock = (uint8_t *)pstCtx->block;\n\n  if ((uiLen >= SHA256_BLOCK_SIZE) || (uiLen + uiBlcLen >= SHA256_BLOCK_SIZE)) {\n    err = memcpy_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, pucData,\n                   SHA256_BLOCK_SIZE - uiBlcLen);\n    if (err != EOK) {\n      pstCtx->corrupted = 1;\n      return SHA256_ERROR;\n    }\n    vosSha256CompressMul(pstCtx, pucBlock, 1);\n    *puiPaddingLen = SHA256_BLOCK_SIZE - uiBlcLen;\n    pstCtx->blocklen = 0;\n    (void)memset_s(pucBlock, SHA256_BLOCK_SIZE, 0, SHA256_BLOCK_SIZE);\n  } else {\n    err = memcpy_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, pucData,\n                   uiLen);\n    if (err != EOK) {\n      pstCtx->corrupted = 1;\n      return SHA256_ERROR;\n    }\n    pstCtx->blocklen += (uint32_t)uiLen;\n    return SHA256_ERROR;\n  }\n\n  return SHA256_OK;\n}\n\nstatic void vosSha256HashByBlcMulti(const uint8_t *pucData, uint32_t uiLen,\n                                    VOS_SHA256_CTX *pstCtx) {\n  errno_t err;\n  uint32_t uiBlcLen;\n  uint32_t uiLenTmp = uiLen;\n  const uint8_t *pucSrc = pucData;\n\n  uiBlcLen = (uint32_t)(uiLenTmp / SHA256_BLOCK_SIZE);\n  if (uiBlcLen > 0) {\n    vosSha256CompressMul(pstCtx, pucSrc, uiBlcLen);\n    uiBlcLen *= SHA256_BLOCK_SIZE;\n    pucSrc += uiBlcLen;\n    uiLenTmp -= uiBlcLen;\n  }\n\n  if (uiLenTmp != 0) {\n    pstCtx->blocklen = (uint32_t)uiLenTmp;\n    err =\n        memcpy_s((uint8_t *)pstCtx->block, SHA256_BLOCK_SIZE, pucSrc, uiLenTmp);\n    if (err != EOK) {\n      pstCtx->corrupted = 1;\n      return;\n    }\n  }\n  return;\n}\n\nvoid vosSha256Hash(const uint8_t *pucData, uint32_t uiLen,\n                   VOS_SHA256_CTX *pstCtx) {\n  uint32_t uiBlcLen = 0;\n  uint32_t uiLenTmp = uiLen;\n  const uint8_t *pucSrc = pucData;\n\n  if ((pucSrc == NULL) || (uiLenTmp == 0) || (pstCtx == NULL) ||\n      (pstCtx->corrupted == 1) || (pstCtx->computed == 1) ||\n      (vosSha256CtxPrepare(pstCtx, uiLenTmp) != SHA256_OK)) {\n    return;\n  }\n\n  if (pstCtx->blocklen != 0) {\n    if (vosSha256LastPadding(pucSrc, uiLenTmp, pstCtx, &uiBlcLen) ==\n        SHA256_OK) {\n      pucSrc += uiBlcLen;\n      uiLenTmp -= uiBlcLen;\n    } else {\n      return;\n    }\n  }\n\n  vosSha256HashByBlcMulti(pucSrc, uiLenTmp, pstCtx);\n  return;\n}\n\nvoid vosSha256End(uint8_t *pucOut, uint32_t uiOutSize, VOS_SHA256_CTX *pstCtx) {\n  uint32_t uiIndex;\n  uint8_t *pucBlock = NULL;\n  uint32_t uiBlcLen;\n\n  if (pstCtx == NULL) {\n    return;\n  }\n\n  pucBlock = (uint8_t *)pstCtx->block;\n  uiBlcLen = pstCtx->blocklen;\n\n  if ((pstCtx->corrupted == 1) || (uiOutSize < pstCtx->outlen)) {\n    (void)memset_s(pstCtx, sizeof(VOS_SHA256_CTX), 0, sizeof(VOS_SHA256_CTX));\n    return;\n  }\n\n  if (pstCtx->computed == 0) {\n    pucBlock[uiBlcLen++] = 0x80;\n    if (uiBlcLen > (SHA256_BLOCK_SIZE - 8)) {\n      (void)memset_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, 0,\n                     SHA256_BLOCK_SIZE - uiBlcLen);\n      uiBlcLen = 0;\n      vosSha256CompressMul(pstCtx, pucBlock, 1);\n    }\n\n    (void)memset_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, 0,\n                   SHA256_BLOCK_SIZE - 8 - uiBlcLen);\n\n    pucBlock += SHA256_BLOCK_SIZE - 8;\n    PUT_UINT32_BE(pstCtx->N[1], pucBlock, 0);\n    pucBlock += sizeof(uint32_t);\n    PUT_UINT32_BE(pstCtx->N[0], pucBlock, 0);\n    pucBlock += sizeof(uint32_t);\n    pucBlock -= SHA256_BLOCK_SIZE;\n    vosSha256CompressMul(pstCtx, pucBlock, 1);\n    pstCtx->blocklen = 0;\n    (void)memset_s(pucBlock, SHA256_BLOCK_SIZE, 0, SHA256_BLOCK_SIZE);\n    pstCtx->computed = 1;\n  }\n\n  uiBlcLen = ((pstCtx->outlen <= uiOutSize) ? pstCtx->outlen : uiOutSize) /\n             sizeof(uint32_t);\n  if (pucOut != NULL) {\n    for (uiIndex = 0; uiIndex < uiBlcLen; uiIndex++) {\n      PUT_UINT32_BE(pstCtx->h[uiIndex], pucOut, sizeof(uint32_t) * uiIndex);\n    }\n  }\n\n  return;\n}\n\nstatic const uint32_t K256[64] = {\n    0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL, 0x3956c25bUL,\n    0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL, 0xd807aa98UL, 0x12835b01UL,\n    0x243185beUL, 0x550c7dc3UL, 0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL,\n    0xc19bf174UL, 0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL,\n    0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL, 0x983e5152UL,\n    0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL, 0xc6e00bf3UL, 0xd5a79147UL,\n    0x06ca6351UL, 0x14292967UL, 0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL,\n    0x53380d13UL, 0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,\n    0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL, 0xd192e819UL,\n    0xd6990624UL, 0xf40e3585UL, 0x106aa070UL, 0x19a4c116UL, 0x1e376c08UL,\n    0x2748774cUL, 0x34b0bcb5UL, 0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL,\n    0x682e6ff3UL, 0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL,\n    0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL,\n};\n\n#define VOS_ROTR32(x, uiBlcLen)                                                \\\n  (((x) << (32 - (uiBlcLen))) | ((x) >> (uiBlcLen)))\n\n#define VOS_ROUND(a, b, c, d, e, f, g, h, i, k, W)                             \\\n  do {                                                                         \\\n    (h) += (VOS_ROTR32((e), 6) ^ VOS_ROTR32((e), 11) ^ VOS_ROTR32((e), 25)) +  \\\n           ((g) ^ ((e) & ((f) ^ (g)))) + (k) + (W)[(i)];                       \\\n    (d) += (h);                                                                \\\n    (h) += (VOS_ROTR32((a), 2) ^ VOS_ROTR32((a), 13) ^ VOS_ROTR32((a), 22)) +  \\\n           (((a) & ((b) | (c))) | ((b) & (c)));                                \\\n  } while (0)\n\nstatic void vosSha256CompressBlock(uint32_t state[VOS_SHA256_CTX_HASH_LEN],\n                                   const uint8_t block[SHA256_BLOCK_SIZE]) {\n  uint32_t W[64];\n  uint32_t i, j;\n  uint32_t a, b, c, d, e, f, g, h;\n\n  for (i = 0; i < 16; i++) {\n    W[i] = GET_UINT32_BE(block, 4 * (i));\n  }\n\n  for (i = 16; i < 64; i++) {\n    W[i] = W[i - 16] + W[i - 7] +\n           (VOS_ROTR32(W[i - 15], 7) ^ VOS_ROTR32(W[i - 15], 18) ^\n            (W[i - 15] >> 3)) +\n           (VOS_ROTR32(W[i - 2], 17) ^ VOS_ROTR32(W[i - 2], 19) ^\n            (W[i - 2] >> 10));\n  }\n\n  j = 0;\n  a = state[j++];\n  b = state[j++];\n  c = state[j++];\n  d = state[j++];\n  e = state[j++];\n  f = state[j++];\n  g = state[j++];\n  h = state[j];\n\n  for (i = 0; i < 64; i += 8) {\n    j = 0;\n    VOS_ROUND(a, b, c, d, e, f, g, h, i + (j++), K256[i + 0], W);\n    VOS_ROUND(h, a, b, c, d, e, f, g, i + (j++), K256[i + 1], W);\n    VOS_ROUND(g, h, a, b, c, d, e, f, i + (j++), K256[i + 2], W);\n    VOS_ROUND(f, g, h, a, b, c, d, e, i + (j++), K256[i + 3], W);\n    VOS_ROUND(e, f, g, h, a, b, c, d, i + (j++), K256[i + 4], W);\n    VOS_ROUND(d, e, f, g, h, a, b, c, i + (j++), K256[i + 5], W);\n    VOS_ROUND(c, d, e, f, g, h, a, b, i + (j++), K256[i + 6], W);\n    VOS_ROUND(b, c, d, e, f, g, h, a, i + j, K256[i + 7], W);\n  }\n\n  j = 0;\n  state[j++] += a;\n  state[j++] += b;\n  state[j++] += c;\n  state[j++] += d;\n  state[j++] += e;\n  state[j++] += f;\n  state[j++] += g;\n  state[j] += h;\n}\n#undef VOS_ROTR32\n#undef VOS_ROUND\n\nstatic void vosSha256CompressMul(VOS_SHA256_CTX *pstCtx,\n                                 const uint8_t *pucInput, uint32_t uiNum) {\n  uint32_t uiNumTmp = uiNum;\n  const uint8_t *pucBlock = pucInput;\n\n  while ((uiNumTmp--) != 0) {\n    vosSha256CompressBlock(pstCtx->h, pucBlock);\n    pucBlock += SHA256_BLOCK_SIZE;\n  }\n}\n\nvoid VOS_Sha256Calc(const uint8_t *pucInput, uint32_t uiInputLen,\n                    uint8_t *pucOutput, uint32_t uiOutputLen) {\n  VOS_SHA256_CTX stCtx;\n\n  vosSha256Begin(&stCtx);\n  vosSha256Hash(pucInput, uiInputLen, &stCtx);\n  vosSha256End(pucOutput, uiOutputLen, &stCtx);\n}\n\n#ifdef __cplusplus\n}\n#endif\n"}